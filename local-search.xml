<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>风一吹，他们，就跳起了舞</title>
    <link href="/2022/03/01/wind-they-dance/"/>
    <url>/2022/03/01/wind-they-dance/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28547432&auto=1&height=66"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NFT 随想</title>
    <link href="/2022/01/15/NFT-Thinking/"/>
    <url>/2022/01/15/NFT-Thinking/</url>
    
    <content type="html"><![CDATA[<p><em>这是马克思作业，顺手发出来</em></p><p>2022年1月6日，“从网络空间到元宇宙的展望：我们将何去何从”国际研讨会在线上举行，作为计算机领域的研究生，对『元宇宙』这样一个新奇的概念，有着与生俱来的好奇心，而『元宇宙』其宏大的愿景，以及混杂其中并大行其道的机会投资，又令人望而生畏。在这样的的背景下，数据空间研究中心承办的『元宇宙』研讨会，吴曼青院士、许彬院士等一众大牛的精彩汇报给我打开了思路，让我尝试着深入理解了一下『元宇宙』。</p><p>我想简要记录一下我在了解『元宇宙』概念中当前最为热门的事物：NFT。NFT是非同质化代币的简写，目前最广为人知的NFT是由Opensea平台提供的NFT数字艺术品。数字艺术品是个很有意思的名字，通常我们想到艺术品想到的是其具有的收藏价值，那些价值连城的艺术品通常都是世界上独一份的珍贵。数字艺术品的数字性意味着其可以随意拷贝，轻松篡改，那么其唯一性似乎几乎是无法保证，那么如何能够作为艺术品来收藏呢。</p><p>我们要思考『元宇宙』出现之前，最热门的概念是区块链。区块链之所以能热门是因为其展现了一个极为远大的愿景，其希望彻底去掉中心化机构，而通过一个基于共识的机制让位于链上的一切都是公开的，人人可见的，绝对可信的。NFT正是基于这样的设计，当一个艺术品被上传到Opensea上时，会自动链上区块链（如ETH，目前公信力较强的链），其在链上会记录这个艺术品的拥有人的地址，那么就认为这个艺术品是属于这个地址的。那么问题来了，只是在链上记录了拥有人地址，怎么保证这个艺术品的唯一性呢？实质上，在我查阅资料后，我认为NFT并不打算限制NFT的唯一性，其认为，作为一件数字艺术品，他在现有的版权体系下，依然可以被任意使用，只是这件艺术品本身，他在一个去中心化的社区中，被公认为是属于在区块链中记录下的地址的，但是任何人都可以使用这件艺术品。那么其收藏价值依然是存在的，因为其是唯一归属的，这件作品被应用的更多可能反而意味着这件作品的价值之高。在这个区块链上，交易只需要在链上账本的地址记录中新增一条即可，因此其是可以被轻松交易的，并且交易成功之后，共识就会转给购买者。</p><p>从技术上看来，这样的概念非常令人神往，他让数字艺术品的使用和归属分离，去中心化的思想，基于社区共识的方案让『假』艺术品无处遁形，然而这真的完美吗？仿制品在艺术品交易中是个极难被解决的问题，数字艺术品的仿制步骤相较实体艺术品更为简单，幸运的是，在NFT中全然不怕仿制品，但如果用户不进行仿制，而是再其基础上二次创作呢，或者说只是修改了几个像素点，其本质上是两件不同的艺术品，但表面上看起来是相近的。那么用户将这个二次创作的艺术品上传到链上，也可以被交易，也是被共识认为是合理的、具有价值的艺术品，但这是不是没有保护好原作者的版权呢？这样的问题其实并不是信口开河，在Opensea中会对用户做明显的区分，主要分为两种，分别是认证用户和非认证用户。大多数时候认证用户上传的作品被认为是原创的，具有极高收藏价值的。这样看来，似乎通过『认证』这个机制可以在一定程度上解决这个问题。但是，Opensea作为一个中心机构，依赖这样一个中心机构是不是与区块链的完全去中心化愿景背道而驰了呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年快乐</title>
    <link href="/2022/01/01/happy-new-year-2022/"/>
    <url>/2022/01/01/happy-new-year-2022/</url>
    
    <content type="html"><![CDATA[<blockquote><p>变成更好的唐唐和森森</p></blockquote><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20220101023126-WechatIMG420.jpeg" alt="2021年12月30日，北京"></p><blockquote><p>阳光从前车窗射入，把我包笼起来，闭上眼睛，感觉得出那光线在暖暖地抚摸着我的眼睑。太阳光沿着漫长的道路抵达这颗小小的行星，用其一端温暖我的眼睑——想到这点，我涌起一股莫名的感动。宇宙运行规律并未忽略我微不足道的眼睑。我好像多少明白了阿辽沙·卡拉马佐夫的心情。或许有限的人生正在被赋予有限的祝福。《世界尽头与冷酷仙境》</p></blockquote><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20220101023140-WechatIMG419.jpeg" alt="2021年12月30日，北京-合肥列车上"></p><blockquote><p>宜·珍惜光阴</p></blockquote><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20220101023226-WechatIMG421.jpeg" alt="2022年1月1日，合肥凌晨"></p>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今年读过的书</title>
    <link href="/2021/12/19/readed-books-2021/"/>
    <url>/2021/12/19/readed-books-2021/</url>
    
    <content type="html"><![CDATA[<p>突然想总结一下2021年看过的书</p><h2 id="雪国"><a href="#雪国" class="headerlink" title="雪国"></a>雪国</h2><p>那时我正在驶向上海的列车上，我的鼻子紧紧抵在玻璃上，恰好让一片连绵不绝的黄色线条经过我的眼睛，我看着窗外愣了神，在想公路代表的究竟是城市还是乡村。在即将久别重逢的喜悦中，夹杂着的难以名状的委屈和时过境迁的悲伤趁着突然出现的黑暗让我眼睛失了焦。我把鼻子移开，看着红色座椅在看不见的原野中疾驰。</p><p>我读完雪国恰是元旦假期，直感身心疲惫，满身的无力感让我几乎又瘫回了那在黑暗中疾驰的红色座椅。</p><h2 id="挪威的森林"><a href="#挪威的森林" class="headerlink" title="挪威的森林"></a>挪威的森林</h2><h2 id="世界尽头与冷酷仙境"><a href="#世界尽头与冷酷仙境" class="headerlink" title="世界尽头与冷酷仙境"></a>世界尽头与冷酷仙境</h2><h2 id="东方快车谋杀案"><a href="#东方快车谋杀案" class="headerlink" title="东方快车谋杀案"></a>东方快车谋杀案</h2><h2 id="一句顶一万句"><a href="#一句顶一万句" class="headerlink" title="一句顶一万句"></a>一句顶一万句</h2><h2 id="艺术的慰籍"><a href="#艺术的慰籍" class="headerlink" title="艺术的慰籍"></a>艺术的慰籍</h2><h2 id="索拉里斯星"><a href="#索拉里斯星" class="headerlink" title="索拉里斯星"></a>索拉里斯星</h2><h2 id="望春风"><a href="#望春风" class="headerlink" title="望春风"></a>望春风</h2>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保持温柔</title>
    <link href="/2021/11/24/keep-soft/"/>
    <url>/2021/11/24/keep-soft/</url>
    
    <content type="html"><![CDATA[<p>在这暖阳下，在这面对蓝天丝毫不闪躲的浪漫星球下，温柔跟宇宙一样，坚不可摧。</p><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20211124224924-IMG_6882.jpg" alt="photos"></p>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>soloris</title>
    <link href="/2021/11/11/soloris/"/>
    <url>/2021/11/11/soloris/</url>
    
    <content type="html"><![CDATA[<p>Skip to main content<br>Posts<br>Published<br>Update </p><blockquote><p>恋人和诗人对爱的力量怀有永恒的信念，认为它比死亡还要持久，但那句千百年来一直缠着我们不放的“生命虽尽，爱犹未尽”，实际上不过是一句谎言。这句谎言只是徒劳无益，并非荒唐可笑。<br>——索拉里斯星</p></blockquote><p>早早计划看完后要写点文字记录一下，脑袋实在很乱，无从下手。不如先留下记录以敦促自己吧</p><p>题外话。经常会听到有人说因为精神贫瘠所以才会追求物质满足。其实我也经常觉得，反倒是因为物质贫瘠，所以才会想要追求精神满足吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/03/01/hello-world/"/>
    <url>/2021/03/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Expression</title>
    <link href="/2021/03/01/expression/"/>
    <url>/2021/03/01/expression/</url>
    
    <content type="html"><![CDATA[<h2 id="Words-words"><a href="#Words-words" class="headerlink" title="Words {words}"></a>Words {words}</h2><ul><li><code>mitigate</code><ul><li>减轻</li></ul></li></ul><blockquote><p>One of the important goals of data center networks is to avoid or <code>mitigate</code> the effect of network bottlenecks on the operation of the computing services offered</p></blockquote><ul><li><code>diversified</code><ul><li>多变化的，各种的</li></ul></li></ul><blockquote><p>By using specialized optimization algorithms and <code>diversified</code> configuration options.</p></blockquote><ul><li><code>seamless</code><ul><li>smoothly and continuously, with no apparent gaps or spaces between one part and the next</li><li>无缝衔接的，平滑的</li></ul></li></ul><blockquote><p>the load balancing service can take the appropriate actions to <code>seamlessly</code> distribute the traffic among the available servers.</p></blockquote><ul><li><code>paramount</code><ul><li>more important than anything else;</li><li>至关重要的</li></ul></li></ul><blockquote><p>Another aspect of <code>paramount</code> importance is the portability of the programming language.</p></blockquote><ul><li><code>Amenable</code> :<ul><li>willing to accept or be influenced by a suggestion;</li><li>意为顺从的，愿意接受建议的，耳朵软的之类的意思。在 OpenFlow 一文中，作者将 Amenable 放在句首，来表达需要实现的功能。</li></ul></li></ul><blockquote><p><code>Amenable</code> to high-performance and low-cost implementations.</p></blockquote><ul><li><code>sophisticated</code><ul><li>having a good understanding of the way people behave and&#x2F;or a good knowledge of culture and fashion:</li><li>intelligent or made in a complicated way and therefore able to do complicated tasks:</li><li>意为复杂精巧的，精于世故的，精通的，富有经验的。此处来形容功能精细复杂的东西。</li></ul></li></ul><blockquote><p>One can also imagine more <code>sophisticated</code> controllers that dynamically add&#x2F;remove ﬂows as an experiment progresses.</p></blockquote><ul><li><code>envisage</code><ul><li>to imagine or expect something in the future, especially something good;</li><li>想象，设想，用来描述技术的前景</li></ul></li></ul><blockquote><p>One could <code>envisage</code> an extension to Ethane in which a policy dictates that particular ﬂows are sent to a user’s process in a controller, hence allowing researcher-speciﬁc processing to be performed in the network.</p></blockquote><ul><li><code>inertia</code><ul><li>lack of activity or interest, or unwillingness to make an effort to do anything</li><li>惰性、惯性、懒惰。作者用来表述某个东西难以推动发展</li></ul></li></ul><blockquote><p>Due to the <code>inertia</code> of current IP networks, a new routing protocol can take five to ten years to be fully designed, evaluated, and deployed.</p></blockquote><ul><li><p><code>alleviate</code></p><ul><li>to make something bad such as pain or problems less severe</li><li>减轻某种痛苦，减轻，缓和，使镇定</li></ul></li><li><p><code>proliferate</code></p><ul><li>to increase a lot and suddenly in number</li><li>激增、增殖，作者用来表达大量东西涌现，也就是激增的含义。</li></ul></li></ul><blockquote><p>To <code>alleviate</code> the lack of in-path functionalities within the network, a <strong>myriad</strong> of specialized components and middleboxes, such as firewalls, intrusion detection systems, and deep packet inspection engines, <code>proliferate</code> in current networks.</p></blockquote><ul><li><p><code>ubiquitous</code></p><ul><li><p>seeming to be everywhere</p></li><li><p>到处存在的</p><blockquote><p>abstractions are essential tools of research in computer science and information technology, being already an <code>ubiquitous</code> feature of many computer architectures and systems.</p></blockquote></li></ul></li><li><p><code>anchor</code></p><ul><li>to lower an anchor into the water in order to stop a boat from moving away;</li><li>to make something or someone stay in one position by fastening him, her, or it firmly;</li><li>锚状物、固定、支撑，赖以支撑的人、物。作者用来表达一个技术依赖于一些东西（这些东西可以避免）</li></ul></li></ul><blockquote><p>However, these technologies are anchored on a box-by-box basis configuration.</p></blockquote><ul><li><code>analogy</code><ul><li>相似，类似，类比</li><li>翻译说是举例来说，我感觉说是类比来看也可以：</li></ul></li></ul><blockquote><p>The base network service functions are what we consider the essential functionality all controllers should provide. <code>As an analogy</code>, these functions are like base services of operating systems, such as program execution, input&#x2F;output (I&#x2F;O) operations control, communications, protection, and so on.</p></blockquote><h2 id="Sentences-sentences"><a href="#Sentences-sentences" class="headerlink" title="Sentences {sentences}"></a>Sentences {sentences}</h2><ul><li><code>同时</code></li></ul><blockquote><p>for instance, allowing the distribution and directing of large groups of client requests without requiring controller intervention for every new flow. <code>In tandem</code>, operation in reactive mode may still be used when traffic bursts are detected.</p></blockquote><ul><li><code>更不用说</code></li></ul><blockquote><p>Commercial switches and routers <code>do not</code> typically provide an open software platform, <code>let alone</code> provide a means to virtualize either their hardware or software.</p></blockquote><ul><li><code>长期看来前景很不错</code> <em>（现在没啥用）</em></li></ul><blockquote><p><code>This approach is promising in the long-term</code>, but for the time being is targeted at large switching centers and is too expensive for widespread deployment in college wiring closets.</p></blockquote><ul><li><code>来满足</code></li></ul><blockquote><p>Programming languages can also provide specialized abstractions <code>to cope with</code> other management requirements, such as monitoring.</p></blockquote><h2 id="Professional-Expression-professional-expression"><a href="#Professional-Expression-professional-expression" class="headerlink" title="Professional Expression {professional-expression}"></a>Professional Expression {professional-expression}</h2><ul><li><code>fine-grained &lt;==&gt; coarser grained</code> 细粒度，粗粒度；</li><li><code>race-free</code> 非竞争的；</li><li><code>single point of failure</code>  单点故障；</li><li><code>heterogeneity</code> 异质性；</li><li><code>Wrapping Up Remarks</code> 总结，结束语；</li><li><code>introduce</code> 引入，提出。</li></ul><h2 id="Good-Sentences-good-sentences"><a href="#Good-Sentences-good-sentences" class="headerlink" title="Good Sentences {good-sentences}"></a>Good Sentences {good-sentences}</h2><blockquote><p>The controller application <strong>needs</strong> to monitor the network traffic <strong>and</strong> use some sort of threshold <strong>in</strong> the flow counters <strong>to</strong> redistribute clients <strong>among</strong> the servers <strong>when</strong> bottlenecks are likely to happen.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一件小事</title>
    <link href="/2021/03/01/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B/"/>
    <url>/2021/03/01/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>世界真的很有趣。学习了一天，终于搭好了我的小博客，马不停蹄地看论文，希望能给博客充值一些干货。然而看一堆数学公式着实让人心累，好在立刻有人提醒我，除了分享技术，还可以写点别的。</p><p>事情的起因源于我在 v 站看到了这样一个帖子：“<a href="https://www.v2ex.com/t/652959">Mac pro 开虚拟机打游戏对电脑有伤害吗？</a>”。</p><p>并无冒犯的说，这样的标题让人忍俊不禁。楼主把帖子发在“新手求助”这样的 Node，也很有虚心求教的意思。但是无奈问题的表述实在让人无法进入想要好好回答的状态，也难免引起下面的回答者就 Mac pro 这个关键词进行“嘲讽”，说嘲讽非我所愿，其实最多也就是开个玩笑吧。</p><p>虽然任何与 Apple 产品相关的话题都会引来一片“嘲讽”，说实话，这样的交流气氛很不好，大家都在调侃楼主，有位同仁有些看不过去，于是说到：“众所周知，请尽量让自己的回复能够对别人有帮助。”但是我觉得根本原因还是在于楼主的提问方式，就我个人而言，我认为问题有二：</p><ul><li>一是开虚拟机打游戏对电脑的影响，应当是可以通过搜索引擎等手段查询到相关信息的,根据获得的信息应当会有一个基本的认知，在这个认知上提出更有针对性的问题应该会更好，比如 Mac 上的虚拟机与 PC 上的虚拟机实现机制不同，Mac 上使用虚拟机打游戏会更容易导致电脑元件老化吗？</li><li>二是“对电脑有伤害吗？”，这样的表述非常的不专业，不严谨，让人无法作答。</li></ul><p>于是我就回复了：“回答需要能提供帮助，但问问题也需要专业。不专业的问题引起的回答只能是互相冒犯。“有些故作深沉的味道，本意是想表达问问题前应当先做些准备的观点。第二天突然收到个通知“活久见”。</p><p>是先前的那位同仁对我的回复。无所谓嘛，不是一路人，也无意去和他辩论。</p><p>但让我想把这件事记录下来，是因为无意中让我看到了这篇帖子“<a href="https://www.v2ex.com/t/653673">在本 V 站提问题不够专业，是否会冒犯回答问题的人？</a>”</p><p>这真是有趣了。无论他是出于什么原因，也无论他这个问题提问得是否专业，我觉得他都冒犯到了我。</p><p>提问当然是需要准备的，无论什么地方，无论什么场合，都应尽量能做到专业。下面粘贴下<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh%5FCN.md">提问的艺术</a>中的“在提问之前”以共勉。</p><blockquote><p><strong>在提问之前</strong></p><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>胡图道理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2021/01/07/test/"/>
    <url>/2021/01/07/test/</url>
    
    <content type="html"><![CDATA[<p>Try to writing something</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱Embedding综述</title>
    <link href="/2020/04/22/KGE-survey/"/>
    <url>/2020/04/22/KGE-survey/</url>
    
    <content type="html"><![CDATA[<p><em>学习<a href="http://ieeexplore.ieee.org/abstract/document/8047276/">Knowledge Graph Embedding: A Survey of Approaches and Applications</a></em></p><h2 id="1-预备知识-1-dot-预备知识"><a href="#1-预备知识-1-dot-预备知识" class="headerlink" title="1. 预备知识 {1-dot-预备知识}"></a>1. 预备知识 {1-dot-预备知识}</h2><p><em>这部分是我自己在阅读过过程中遇到不懂的地方，自行查阅记录，以供理解</em></p><ul><li>Embedding:是一个将离散变量转为连续向量表示的一个方式，不光可以减少离散变量的空间维数，同时还可以有意义的表示该变量。上面这句话的意思就是说，把词语拆成指定数量的特征维度，每一个词都可以用这些维度组合成的向量来表示（word embedding 的含义<a href="%E5%8F%82%E8%80%83%E8%87%AA%3Chttps://www.zhihu.com/question/38002635">^fn:1</a>）。相对于稀疏的 one-hot 编码而言，这样的编码可以表示出不同的词语之间的临近关系。</li><li>tensor: 张量，在物理学中张量被定义为是一种无关于坐标系的物理量，不需要进行线性（坐标）变换，以统一的方式表达定理的物理量，但是在机器学习中，显然不是这个意思。张量在这里指的是一个多维的数据存储形式，维度被称之为张量的阶(mode)，可以看成向量和矩阵在多维空间的推广，即把向量看作一维张量，矩阵看作二维张量。上述信息和张量的一些运算法则可以参考这篇<a href="http://www.xiongfuli.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2016-06/tensor-decomposition-part1.html">文章</a></li><li>Circular Correlation: 循环相关，对应的是线性相关。相关反应的是同步性、相似性、同相性等，具体的计算方法就是给定位移量 m，计算 x 和 y+m 的对应的点的乘积的和，线性相关的计算公式为： \(r_{xy}(m) &#x3D; \sum_{n&#x3D;-\infty}^{+\infty} x(n) y(n+m)\) 。循环相关稍微复杂一点，首先要将上面的有限序列通过向左循环移位得到周期序列（周期就是序列的原长度），然后套用公示进行计算： \(r_{xy}(m) &#x3D; \sum_{n&#x3D;0}^{N-1} x(n) y((n+m))_N R_N(n)\) ，计算过程就是循环移位(偏移 m 是多少就移位多少)相乘的乘积和，具体计算过程和理论参考<a href="http://read.pudn.com/downloads70/ebook/254107/ch4.pdf">文章</a>，发现论文中的公式更简单： \([a \star b]_i &#x3D; \sum_{k&#x3D;0}^{n-1}[a]_k [b]_{(k+i)<del>mod</del>n}\) .<ul><li><em>计算示例</em></li></ul></li></ul><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20200423213305-screen-shoot.png"></p><ul><li>超平面(HyperPlanes)，指的是用来切分当前高维空间的切分平面，比如三维空间中的一个分割平面，二维空间中的一条分割线。n维空间中的n-1维的空间。</li></ul><h2 id="2-介绍-2-dot-介绍"><a href="#2-介绍-2-dot-介绍" class="headerlink" title="2. 介绍 {2-dot-介绍}"></a>2. 介绍 {2-dot-介绍}</h2><h3 id="2-1-知识图谱-2-dot-1-dot-知识图谱"><a href="#2-1-知识图谱-2-dot-1-dot-知识图谱" class="headerlink" title="2.1. 知识图谱 {2-dot-1-dot-知识图谱}"></a>2.1. 知识图谱 {2-dot-1-dot-知识图谱}</h3><p>知识图谱就是一个多关系图，由实体和关系组成，每个边都是一个三元组：(head, relation, tail)，这个三元组又被成为<code>fact</code>。</p><h3 id="2-2-知识图谱嵌入-2-dot-2-dot-知识图谱嵌入"><a href="#2-2-知识图谱嵌入-2-dot-2-dot-知识图谱嵌入" class="headerlink" title="2.2. 知识图谱嵌入 {2-dot-2-dot-知识图谱嵌入}"></a>2.2. 知识图谱嵌入 {2-dot-2-dot-知识图谱嵌入}</h3><p>知识图谱（KG）Embedding 是将包含实体和关系的 KG 组件嵌入到连续的向量空间中，以便简化操作，同时保留 KG 的固有结构。</p><h3 id="2-3-知识图谱嵌入的通常做法-2-dot-3-dot-知识图谱嵌入的通常做法"><a href="#2-3-知识图谱嵌入的通常做法-2-dot-3-dot-知识图谱嵌入的通常做法" class="headerlink" title="2.3. 知识图谱嵌入的通常做法 {2-dot-3-dot-知识图谱嵌入的通常做法}"></a>2.3. 知识图谱嵌入的通常做法 {2-dot-3-dot-知识图谱嵌入的通常做法}</h3><p>给定一个 KG，嵌入技术首先使用连续向量空间表示实体和关系，并为每个 fact 定义一个评分函数以衡量其合理性。通过最大化已有的 fact 的得分来获得实体和关系的 Embed。</p><blockquote><p>但是上述过程学习到的 Embedding 只在针对单个 fact 具有<strong>compatible</strong>，因此不具有<strong>可预测性</strong>。</p></blockquote><p>因此现在会考虑使用更多信息诸如：<strong>实体类型、关系路径、文本描述、逻辑规则</strong>来让 Embedding 更具有预测性。</p><p><strong>具体来说就是只使用 fact 的方法不具有可预测性，因此需要结合其他信息。</strong></p><h2 id="3-方法-3-dot-方法"><a href="#3-方法-3-dot-方法" class="headerlink" title="3. 方法 {3-dot-方法}"></a>3. 方法 {3-dot-方法}</h2><h3 id="3-1-Trans系列-3-dot-1-dot-trans系列"><a href="#3-1-Trans系列-3-dot-1-dot-trans系列" class="headerlink" title="3.1. Trans系列 {3-dot-1-dot-trans系列}"></a>3.1. Trans系列 {3-dot-1-dot-trans系列}</h3><ul><li>TransE在上篇博文以详细描述，它的score函数为 \(f_r(h,t) &#x3D; -||h+r-t||_{1&#x2F;2}\)<ul><li>但是TransE在处理1-N, N-1和 N-N时就会出现问题，比如当同一个实体的某一关系有多个对应时，尽管t的意义可能完全不同，但是TransE也会让他们尽量相似，比如我喜欢狗狗和冰淇淋就会把狗狗和冰淇淋表现的很相似。</li></ul></li><li>为了避免这个问题，一种解决方法是允许实体在不同的关系下有不同的representation，<ol><li>TransH使用<strong>超平面</strong>的方法，relation用r上的法向量为 \(w_r\) 的超平面来表示。给定一个fact (h,r,t)，首先要把h和t投射到超平面上，<ul><li>\(h_{\perp} &#x3D; h- w_r^{\top}hw_r\) , \(t_{\perp} &#x3D; t - w_r^{\top}hw_r\)</li><li>score函数为：\(f_r(h,t) &#x3D; - ||h_{\perp} + r - t_{\perp}||_2^2\)</li></ul></li><li>TransR与TransH类似，其为relation定义特定的空间（维度），即定义Entity为d维，但定义relation为k维，对于fact (h,r,t)，先使用投射矩阵 \(M_r\) 把h和t投射到k维上:<ul><li>\(h_{\perp} &#x3D; M_rh\), \(h_{\perp} &#x3D; M_rt\)</li><li>score函数与TransH相同。</li><li>TransR的表达能力很强，但是TransR有个很严重的问题，因为投射矩阵的存在其需要的参数复杂度达到了O(dk)</li></ul></li><li>TransD通过将投射矩阵分解为两个vector $w_r, w_t$，然后根据这两个向量获得投射矩阵 \(M_r^1, M_r^2\)<ul><li>\(M_r^1 &#x3D; w_rw_h^{\top} + I, M_r^2 &#x3D; w_rw_t^{\top} + I\)</li><li>\(h_{\perp} &#x3D; M_r^1h, t_{\perp} &#x3D; M_r^2t\)</li></ul></li><li>TranSparse通过稀疏投射矩阵来减少参数，使用 &amp;theta; 表示稀疏程度，其有两个版本，分别是用同一个 \(M_r(\theta_r)\) 和用不同的 \(M_r^1(\theta_r^1)h, M_r^2(\theta_r^2)\)<ul><li>\(h_{\perp} &#x3D; M_r(\theta_r)h\) 或 $h<sub>&amp;perp;</sub> &#x3D; M_r^1(&amp;theta;_r^1)h$，后面略</li></ul></li></ol></li><li>另一种解决思路是放宽TransE中 \(h+r \approx t\) 这个条件。<ol><li>TransM给每个fact添加了一个权重&amp;theta;，为1-N,N-1,N-N分配更小的权重，是的t可以在这些relation中离h+r更远。score函数为：<ul><li>\(f_r(h,t) &#x3D; -\theta_r ||h+r-t||_{1&#x2F;2}\)</li></ul></li><li>MoanifoldE放宽条件到 $||h+4-t||_2^2 &amp;asymp; &amp;theta;_r^2$，从而使得t可以在h+r附近的一个圆内，而不是一个点：<ul><li>\(f_r(h,t) &#x3D; -(||h+r-t||_2^2 - \theta_r^2)^2\)</li></ul></li><li>TransF通过尽让t和h+r在一个方向，同时h和t-r在同一个方向来放松条件：<ul><li>\(f_r(h,t) &#x3D; (h+r)^{\top}t + (t-r)^{\top}h\)</li></ul></li><li>TransA使用了马氏空间，相比较 TransE 模型，引入了 \(W_r\) 矩阵为不同维度的向量进行加权，并利用 LDL 方法对 \(W_r\) 进行分解:<ul><li>\(f_r(h,t) &#x3D; -(|h+r-t|)^{\top} M_r (|h+r-t|)\)</li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransE，连接多关系实体</title>
    <link href="/2020/04/19/TransE/"/>
    <url>/2020/04/19/TransE/</url>
    
    <content type="html"><![CDATA[<h2 id="Point-point"><a href="#Point-point" class="headerlink" title="Point {point}"></a>Point {point}</h2><p>本次学习的是知识表示、知识工程、知识图谱之类的中一篇很重要的论文，<a href="http://papers.nips.cc/paper/5071-translating-embeddings-for-modeling-multi-relational-data.pdf">TransE: Translating Embeddings for Modeling Multi-relational Data</a>，讲述的是如何对多关系的实体进行连接。直接来讲就是要使得 <code>h+l=t</code>。</p><h2 id="需要知道的东西-需要知道的东西"><a href="#需要知道的东西-需要知道的东西" class="headerlink" title="需要知道的东西 {需要知道的东西}"></a>需要知道的东西 {需要知道的东西}</h2><p>什么是知识图谱，一种定义是“知识图谱是语义网络上的知识库”，也就是个多关系图。他的目的就是要表示出实体与实体之间的关系，实体指的是现实世界中的事物比如人、地名、概念、药物、公司等，关系则用来表达不同实体之间的某种联系，比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。又比如人和人之间的关系可以是“朋友”，也可以是“同事”关系。构建这样的一个知识图谱就获得了一个结构化的知识库，当我们执行搜索的时候，就可以通过关键词提取（”张三”, “李四”, “朋友”）以及知识库上的匹配可以直接获得最终的答案[^fn:1]。</p><p>多关系数据的有向图里面的节点就是<strong>实体Entities</strong>，而边则象征着这样一个<strong>三元组(h, l, t)<strong>，(head, label, tail)，每个边表示的就是在实体head和tail之间有着名为label的关系。我们要做的是要学习出实体与关系之间的</strong>表示</strong>。</p><h2 id="方法-方法"><a href="#方法-方法" class="headerlink" title="方法 {方法}"></a>方法 {方法}</h2><p>文章强调使用了embedding 空间的translation来表示关系，从而得到了很好的效果，那么为什么“翻译”能够表示关系呢？实际上我觉得这里的translation表达的应该是<strong>转移</strong>。也就是说从一个向量转移到另一个向量，而转移的过程就是两个向量的关系，使用null转移向量就可以表示实体之间的等价关系了，所以看起来，用转移是可以表示的。</p><p>那么怎么表示转移呢？数轴中，a+b可以表示a向右移动了b个单位，那么h+l也可表示h移动了l个单位，因此答案呼之欲出，要使得<strong>h+l&#x3D;t</strong>。</p><h2 id="实现-实现"><a href="#实现-实现" class="headerlink" title="实现 {实现}"></a>实现 {实现}</h2><p>给定训练集S，S包含一系列三元组(h,l,t)，其中h,t &amp;isin; E(实体集)，l &amp;isin; L(关系集)，要把实体和关系embed到k维，其中k是一个超参数。本质想法就是要使得(h,l,t)这条关系存在时，尽量使得h+l &amp;asymp; t，而反之则尽量远离。采用基于energy的方法表示这个目标（这个基于energy的方法没有搞懂他的描述目的，但从公式和代码来看，这里的判断标准就是计算距离。）即使用d(h,l,t)，其中d可以是 \(L_1, L_2\) 范数。</p><p>损失函数如下：</p><p>\[<br>\mathcal L &#x3D; \sum_{(h,l,t) \in S} ~ \sum_{(h’,l,t’) \in S’_{(h,l,t)}} [\lambda + d(h+l, t) - d(h’+l,t’)]_+<br>\]</p><p>其中$[x]_+$表示$x$中的正数部分。并且：</p><p>\[<br>S’_{(h,l,t)} &#x3D; \{ (h’,l,t)|h’ \in E \} \cup \{ (h,t,l’) | t’ \in E \}<br>\]</p><p>上式构造不正确的三元组，头部或尾部被随机实体代替（但肯定有一个是属于训练项中的实体）。</p><p>这样通过随机梯度下降进行训练，就能实现有关系的距离近，没关系的距离远。如下：</p><p> ![](figure src&#x3D;”<a href="https://gitee.com/layer3/pic/raw/master/uPic/20200419230343-screen-shoot.png&quot;">https://gitee.com/layer3/pic/raw/master/uPic/20200419230343-screen-shoot.png&quot;</a>)</p><p>先根据前人[^fn:2]提出的随机过程初始化实体和关系的所有Embed。在算法的每个主要迭代中，实体的嵌入向量首先进行归一化。然后，从训练集中采样一小部分三元组，并将其作为一个batch的训练三元组。然后，对于每个这样的三元组，我们产生一个不正确的三元组。然后通过采用具有恒定学习率的梯度步骤来更新参数。根据算法在验证集中的性能停止更新。</p><h2 id="我的问题-我的问题"><a href="#我的问题-我的问题" class="headerlink" title="我的问题 {我的问题}"></a>我的问题 {我的问题}</h2><p>那么训练出来的结果是什么呢？</p><p>训练出来的结果就是对关系和实体的Embed vector，也就是实体和关系的低维向量，并且满足，如果有(h,l,t)的话，就会有h+l&#x3D;t[^fn:3]。</p><p>$$<br>a^b &#x3D; 3_1<br>$$</p><p>[^fn:1]: 参考自机器之心 <a href="https://www.jiqizhixin.com/articles/2018-06-20-4">https://www.jiqizhixin.com/articles/2018-06-20-4</a>;<br>[^fn:2]: X. Glorot and Y. Bengio. Understanding the difﬁculty of training deep feedforward neural networks. In Proceedings of the International Conference on Artiﬁcial Intelligence and Statistics (AISTATS)., 2010.<br>[^fn:3]: 感谢ZJU的陈少帮助我解疑答惑。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge_Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件定义网络</title>
    <link href="/2020/03/22/sdn/"/>
    <url>/2020/03/22/sdn/</url>
    
    <content type="html"><![CDATA[<p><em>软件定义网络即 SDN，是我一直以来想要研读的一个方向，在完成了 NSFC 的申请书之后，终于闲了一些，决定从头开始，先对 SDN 有个初步的了解，然后再深入进去，进行查缺补漏式的系统学习，以开展相应的研究和实验。目前第一步已经看完了 OpenFlow 的开山之作，具体可以看这篇<a href="https://www.ansont.cn/posts/openflow">博文</a>，这篇博文主要是阅读 SDN 的一篇综述“Softwoare-Defined Networking: A Comprehensive Survey”的学习总结</em></p><h2 id="1-为什么-1-dot-为什么"><a href="#1-为什么-1-dot-为什么" class="headerlink" title="1. 为什么 {1-dot-为什么}"></a>1. 为什么 {1-dot-为什么}</h2><p>在介绍 SDN 之前，需要先说明为什么需要 SDN，也就是现在的网络架构有什么问题？</p><ul><li>传统的 IP 网络太<code>复杂</code>难以管理、配置和实施高层策略。（管理员要针对每个设备根据设备厂商的不同慢慢配置）</li><li>现有的网络在垂直层面是<code>紧耦合</code>的，也就是控制层和数据层是在交换机和路由器这些网络设备上绑定在一起的，这就很不 flexibility 了，并且这也让网络协议的更新换代变得十分困难。</li></ul><p>SDN 为改变上面的问题，做了哪些工作呢？</p><ul><li><code>分离</code>控制层与数据层，也就是把控制逻辑从转发流量的步骤中拿了出来。</li><li>网络中的路由器就只是简单的转发设备，而控制逻辑放在逻辑上中心化<a href="%E8%AF%B4%E9%80%BB%E8%BE%91%E4%B8%8A%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%89%A9%E7%90%86%E4%B8%8A%E5%A4%A7%E5%A4%9A%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%BE%88%E5%A4%9A%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E3%80%81%E6%80%A7%E8%83%BD%E6%89%A9%E5%B1%95%E6%80%A7%E4%B8%8D%E4%BD%B3%E7%AD%89%E3%80%82">^fn:1</a>的控制设备上，也就简化了配置和迭代。</li></ul><h2 id="2-介绍-2-dot-介绍"><a href="#2-介绍-2-dot-介绍" class="headerlink" title="2. 介绍 {2-dot-介绍}"></a>2. 介绍 {2-dot-介绍}</h2><h3 id="2-1-网络的拆分-2-dot-1-网络的拆分"><a href="#2-1-网络的拆分-2-dot-1-网络的拆分" class="headerlink" title="2.1 网络的拆分 {2-dot-1-网络的拆分}"></a>2.1 网络的拆分 {2-dot-1-网络的拆分}</h3><p>计算机网络可以被分为三层：</p><ul><li>管理层：监测和配置管理层，<strong>定义网络策略</strong>；</li><li>控制层：表示管理数据层元素的转发表的协议，<strong>实施(enforce)策略</strong>；</li><li>数据层：用来转发数据，<strong>通过转发相应的数据来执行(excutes)策略</strong>。</li></ul><p>![](figure src&#x3D;”&#x2F;ox-hugo&#x2F;2020-03-23_22-02-16_screen-shoot.png” width&#x3D;”300”)</p><h3 id="2-2-什么是-SDN-2-dot-2-什么是-sdn"><a href="#2-2-什么是-SDN-2-dot-2-什么是-sdn" class="headerlink" title="2.2 什么是 SDN {2-dot-2-什么是-sdn}"></a>2.2 什么是 SDN {2-dot-2-什么是-sdn}</h3><h4 id="2-2-1-基本构成-2-dot-2-dot-1-基本构成"><a href="#2-2-1-基本构成-2-dot-2-dot-1-基本构成" class="headerlink" title="2.2.1 基本构成 {2-dot-2-dot-1-基本构成}"></a>2.2.1 基本构成 {2-dot-2-dot-1-基本构成}</h4><p>文章认为 SDN 的架构由四大支柱构成：</p><ol><li>控制与数据层分离；</li><li>转发决策是基于 flow 的，而不是基于目的地址的。flow 这个抽象使得不同类型的网络设备（比如路由器、交换机、防火墙等）可以统一行为，极大的增加了灵活性（但可能受到流表<code>功能</code>上的限制？）；</li><li>控制逻辑被移动到外部实体，被称之为 SDN Controller 或者 NOS<a href="%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%AE%83%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E4%B8%8A%E9%9B%86%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BD%91%E7%BB%9C%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E5%BF%85%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90%E5%92%8C%E6%8A%BD%E8%B1%A1%EF%BC%8C%E4%BB%A5%E4%BF%83%E8%BF%9B%E8%BD%AC%E5%8F%91%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BC%96%E7%A8%8B%E3%80%82">^fn:2</a>，可以基于此抽象对转发设备进行编程；</li><li>网络可以通过运行在 NOS(其与数据层设备交互) 之上的软件程序来进行编程。</li></ol><h4 id="2-2-2-抽象的方法-2-dot-2-dot-2-抽象的方法"><a href="#2-2-2-抽象的方法-2-dot-2-dot-2-抽象的方法" class="headerlink" title="2.2.2 抽象的方法 {2-dot-2-dot-2-抽象的方法}"></a>2.2.2 抽象的方法 {2-dot-2-dot-2-抽象的方法}</h4><p>通过抽象的方法可以帮助我们更好地理解计算机科学中的很多事物，SDN 也不例外。SDN 可以被认为是由三大抽象构成的：</p><ul><li><code>Forwarding abstraction</code> ，可以类比于 OS 中的驱动，实现网络程序要求的各种转发行为；</li><li><code>Distribution abstraction</code> ，所有的分布式系统都依赖于网络，而实际上，网络本身就是个大的分布式系统，所以通过这个通用的 Distribution Layer（比如 NOS），来处理分布式系统中的状态，提供一个中心化的使用体验。具体来说需要具有两大功能：<ul><li>给转发设备安装控制指令(installing the control commands on the forwarding devices)；</li><li>收集转发层(forwarding layer)层的状态信息，从而给网络应用提供一种全局的 view。</li></ul></li><li><code>Specification abstraction</code> ，让网络应用可以表达它希望网络执行的行为而不用具体实现该行为。通过虚拟化或者编程语言的方式来实现，文章中说是把抽象的配置（configuration)映射到由 SDN 控制器暴露出来的全局网络的实际的物理配置上，(<em>这么看确实像程序语言干的事，此处未完全理解，存疑</em>)。</li></ul><p>![](figure src&#x3D;”<a href="https://i.loli.net/2020/03/23/V6u9bo8CSU35TwD.png&quot;">https://i.loli.net/2020/03/23/V6u9bo8CSU35TwD.png&quot;</a> width&#x3D;”400”)</p><h4 id="2-2-3-术语定义-2-dot-2-dot-3-术语定义"><a href="#2-2-3-术语定义-2-dot-2-dot-3-术语定义" class="headerlink" title="2.2.3 术语定义 {2-dot-2-dot-3-术语定义}"></a>2.2.3 术语定义 {2-dot-2-dot-3-术语定义}</h4><ol><li><code>Forwarding Devices(FD)</code>，用来执行的一些基本操作的数据层设备，其拥有一些实现定义好的指令集（比如转发到和端口之类的），这些指令集实际上由南向接口 southbound interfaces 定义的，并由 SDN 控制器安装在转发设备中以实现南向协议；</li><li><code>Data Plane(DP)</code>，网络中的转发设备的集合就是一个数据层，这里的集合表示这些设备是通过无线或有线连接着的；</li><li><code>Southbound Interface(SI)</code>，主要用来表示控制层与数据层之间的交互；<ul><li>FD 中的指令集就是由南向 API 定义的，南向 API 是 SI 的一部分；</li><li>定义控制层与 SD 之间的通信协议。</li></ul></li><li><code>Control Plane(CP)</code>，FD 是被 CP 通过 SI 实体来编程的，相当于是网络的大脑，所有的逻辑都在应用程序和控制器中，也就是在控制层中；</li><li><code>Northbound Interface(NI)</code>，NOS 给 APP 开发者提供 API，这个 API 就是 NI，本质上，NI 通常对 SI 使用的底层的指令集进行抽象，来对 FD 进行编程；</li><li><code>Management Plane(MP)</code>，利用 NI 提供的功能（函数）来实现网络控制和操作逻辑的应用程序集合，（包括路由、防火墙等等），管理程序定义策略，这些策略被最终翻译为南向的特定指令，来编程 FD 的行为。</li></ol><h2 id="3-Software-defined-Networks-3-dot-software-defined-networks"><a href="#3-Software-defined-Networks-3-dot-software-defined-networks" class="headerlink" title="3. Software-defined Networks {3-dot-software-defined-networks}"></a>3. Software-defined Networks {3-dot-software-defined-networks}</h2><h3 id="3-1-Layer-I-Infrastructure-3-dot-1-layer-i-infrastructure"><a href="#3-1-Layer-I-Infrastructure-3-dot-1-layer-i-infrastructure" class="headerlink" title="3.1 Layer I: Infrastructure {3-dot-1-layer-i-infrastructure}"></a>3.1 Layer I: Infrastructure {3-dot-1-layer-i-infrastructure}</h3><p>下图表示了基于 OpenFlow 的 SDN 设备的结构和逻辑<br><img src="https://gitee.com/layer3/pic/raw/master/uPic/screen-shoot%204.png"></p><p>Infrastructure 主要介绍的是那时支持 SDN 设备的基本构成，基本在上图可以看到，不过值得注意的是这样一个事实：</p><blockquote><p>软件实现的交换机是一个实现数据中心网络和网络虚拟化的很有前景的想法。e.g. Switch light, ofsoftswitch, Open vSwitch, Pica8, Pantou, XorPlus。</p></blockquote><p>我觉的这是一个值得研究的点，如果目前还是一个“很有前景的“而不是非常完善的领域的话。</p><h3 id="3-2-Layer-II-Southbound-Interfaces-3-dot-2-layer-ii-southbound-interfaces"><a href="#3-2-Layer-II-Southbound-Interfaces-3-dot-2-layer-ii-southbound-interfaces" class="headerlink" title="3.2 Layer II: Southbound Interfaces {3-dot-2-layer-ii-southbound-interfaces}"></a>3.2 Layer II: Southbound Interfaces {3-dot-2-layer-ii-southbound-interfaces}</h3><p>或者叫<code>Southbound APIs</code>，作为连接 FD 和 Control 的桥梁，非常重要。与 OpenFlow 提出时想要解决的问题一样，这些 API 目前还是和 FD 的底层物理实现或虚拟设施等紧相关。传统的设备各个厂商之间的实现方法不同，API 不通用，使用诸如 OpenFlow 这样的南向 API 可以为不同厂商生产的 OpenFlow-enabled 的设备带来互操作性(interoperability)。作为数据和控制层之间的通信笑到，OpenFlow 协议为 NOS 提供三种信息通道：</p><ul><li>当链路或端口变化被发现时，FD 给 controller 发送的基于<code>事件</code>的 message；</li><li>FD 生成的<code>统计数据</code>发送给 Controller 以收集统计；</li><li>当转发设备不知道如何处理<code>新</code> 的传入流时，或者由于流表的匹配条目中有明确的“<code>发送到控制器</code>”操作，packet-in messages 将由转发设备发送到控制器。</li></ul><p><code>这些信息通道是给NOS提供*流级别*信息的基本手段</code></p><p>下面概述在南向 API 方面的探索。本质上是为转发设备提供一种可编程的接口，一些探索是为了给 OpenFlow 纠偏，另一些则是根本上的新思路。</p><ul><li><code>ForCES</code>，将控制和数据分离，但是仍然在一个网络设备中；</li><li><code>OVSDB</code>，相当于 OpenFlow 的补充协议，可以提供更多功能（诸如 QoS 策略，控制 OpenFlow 数据路径的信道接口等）；</li><li><code>POF</code>，为了加强 SDN 的转发层。在 OpenFlow 里面，转发设备必须对头部进行解析来找到与流表条目匹配的数据位，这意味着数据层设备需要为此花费严重，同时 OpenFlow 的更新换代，对头部的解析就更困难了。为此 POF 提出了一种 generic flow instruction set(FIS)，是的转发设备像是一个只有处理和转发能力的白盒，<code>包解析任务由控制器来完成</code>，返回给转发设备一系列 Keys 和查表指令（安装在转发设备中的）；</li><li><code>OpFlex</code>，把一部分网络管理功能<code>返还给转发设备</code>，这体现了 SDN 中的一个问题：就在什么地方放置哪些功能？</li><li><code>OpenState</code>，用<code>有限状态机</code>来让转发设备执行几个有状态任务，而<strong>不会增加控制平面的复杂性或开销</strong>，这使的所有只涉及本地状态的任务（比如 MAC 地址学习操作）可以直接在转发设备中执行，而不用和三控制器通信；</li><li><code>ROFL</code>，其直接提供了一种抽象层，隐藏各种版本的 OpenFlow 协议的区别；</li><li><code>HAL</code>，其准确来说不算是南向 API，它更像是属于转发设备和南向 API 直接的那一层，作为一个<strong>翻译器</strong>将诸如 OpenFlow 这样的南向 API 翻译后来控制硬件设备；</li><li><code>PAD</code>，通过使用通用字节操作、定义协议头和提供功能定义来控制数据路径行为，从而对转发设备进行更通用的编程。</li></ul><h3 id="3-3-Layer-III-Network-Hypervisors-3-dot-3-layer-iii-network-hypervisors"><a href="#3-3-Layer-III-Network-Hypervisors-3-dot-3-layer-iii-network-hypervisors" class="headerlink" title="3.3 Layer III: Network Hypervisors {3-dot-3-layer-iii-network-hypervisors}"></a>3.3 Layer III: Network Hypervisors {3-dot-3-layer-iii-network-hypervisors}</h3><p>现在虚拟机化技术应用的很广泛，特别是虚拟机迁移，非常灵活且易于管理，但是目前的网络还需要一个设备一个设备的配置。网络需求可以被分为两大类：<strong>network topology</strong>和<strong>address space</strong>。而这两个在目前的架构中都很难虚拟化，不可能找到一个拓扑能够适用于所有任务，而现在地址空间也是很难改变，虚拟化工作负载必须在物理基础架构的相同地址中运行。所以要实现完全的虚拟化，就要实现网络虚拟化，要实现网络虚拟化就要做到可以支持任意网络拓扑结构和地址模式，同时系统迁移也应该可以自动引虚拟起网络端口的迁移。目前已有的虚拟化方案类似于 VLANS, NAT 和 MPLS 这样的虚拟化够了，但是还是需要一个一个的配置。作者将现有的研究分为网络切片和商业多租户网络管理工具两部分。</p><p><strong>1) Slicing the Network</strong></p><ul><li><code>FlowVisor</code>，让多种逻辑网络分享相同的 OpenFlow 基础结构，提供一个抽象层让对数据平面可以容易进行切片。主要考虑了这样几个纬度：<strong>带宽，拓扑，traffic，CPU 核心和转发表</strong>，并且每个网络切片支撑一个控制器，也就是说多控制器可以在同样的物理网络基础设施上共存，每个控制器只能管理自己的网络切片。从系统设计的角度来看，FlowVisor 是一个传输代理，劫持交换机和控制器的 OpenFlow 消息。它划分每个交换机的链路带宽、流表和每个分片接收最小数据速率，每个控制器在交换机中获得自己的虚拟流表。</li><li><code>OpenVirtex</code>，其像是一个在转发设备和 NOS 之间的代理，其主要目标是要通过虚拟化<strong>拓扑、地址和控制函数</strong>来提供虚拟 SDNs。虚拟网络拓扑必须映射到基础转发设备上，虚拟地址允许租户完全管理其地址空间，而无需依赖基础网络元素寻址方案。</li><li><code>AutoSlice</code>，重点关注虚拟 SDN（vSDN）拓扑的部署和操作的<strong>自动化</strong>，使得底层网络运营商进行的调解或仲裁最少。通过优化资源利用率并通过<strong>对流量统计进行精确监</strong>控来减轻流表限制，可以实现网络管理程序的可扩展性方面。</li><li><code>AutoVFlow</code>，提供多域的网络虚拟化，不是单一的第三方来控制和映射网络拓扑，而使用多代理结构，让网络拥有者通过以在不同域上交换信息的方法自动化实现流空间虚拟化。</li><li><code>FlowN</code>，FlowN 与上面的虚拟化不同，上面的虚拟化可以类比于完全虚拟化，那么 FlowN 就可以类比于容器(Container[^fn:3])虚拟化，FlowN 最初还主要用于在云平台的环境下解决多租户问题，它被设计为可伸缩的，并允许使用独特的共享控制器平台来管理云环境中的多个域，每个租户都可以完全控制其虚拟网络，并可以在控制器平台之上自由部署任何网络抽象和应用程序。</li><li><code>compositional SDN hypervisor</code>，主要目标是：允许协作多个用不用语音编写的程序能够（顺序、并行）执行，或者设计用于各种控制平台，因此为典型网络管理程序提供了 interoperability 和 portability。</li></ul><p><strong>2） 商业多租户网络管理程序</strong>，主要是要能提供底层转发设备和物理网络拓扑的抽象，并且每个租户可以控制自己的抽象和独立管理自己的虚拟网络（意味着不用和其他租户打交道）</p><ul><li><code>NVP</code>，由 VMWare 提出，主要提供了必要的抽象，来允许在多租户环境下创建独立的虚拟网络。在同一个物理网络上包含独立的服务模型、拓扑和地址结构。NVP 网络管理程序把用户的配置和需求翻译成底层指令，安装在转发设备上。该平台使用 SDN 控制器<strong>集群</strong>来操纵主机管理程序中 Open vSwitch 的转发表。因此，转发决策仅在<strong>网络边缘</strong>上做出。做出决定后，数据包将通过物理网络通过隧道传输到接收主机管理程序（物理网络只能看到普通 IP 数据包）。</li><li><code>SDN VE</code>，由 IBM 提出，使用 OpenDaylight 作为被称为 SDE 的一个构建块，于 NVP 类似，其实用了基于主机的覆盖 approach，为多租户应用层网络抽象服务。</li></ul><h3 id="3-4-Layer-IV-Network-Operating-System-x2F-Controllers-3-dot-4-layer-iv-network-operating-system-controllers"><a href="#3-4-Layer-IV-Network-Operating-System-x2F-Controllers-3-dot-4-layer-iv-network-operating-system-controllers" class="headerlink" title="3.4 Layer IV: Network Operating System&#x2F;Controllers {3-dot-4-layer-iv-network-operating-system-controllers}"></a>3.4 Layer IV: Network Operating System&#x2F;Controllers {3-dot-4-layer-iv-network-operating-system-controllers}</h3><p>为什么需要网络操作系统？操作系统的作用就是对底层的异质的硬件等资源进行抽象，方便上层应用进行开发，在网络上也是一样的，路由算法的设计者在解决网络问题时往往需要处理复杂的分布式算法，并且这些问题要一直被重复处理。SDN 为解决这样的问题提出 NOS 来实现逻辑集中的控制，主要包括抽象、必要服务和开发者需要的共同的 API。可以将诸如<strong>网络状态</strong>和<strong>网络拓扑信息</strong>，<strong>设备发现</strong>以及<strong>网络配置的分布</strong>之类的通用功能作为 NOS 的服务来提供。这样网络策略开发者就不用管底层的实现细节了。</p><h4 id="3-4-1-系统设计维度-3-dot-4-dot-1-系统设计维度"><a href="#3-4-1-系统设计维度-3-dot-4-dot-1-系统设计维度" class="headerlink" title="3.4.1 系统设计维度 {3-dot-4-dot-1-系统设计维度}"></a>3.4.1 系统设计维度 {3-dot-4-dot-1-系统设计维度}</h4><p>分为<strong>集中式</strong>和<strong>分布式</strong>。</p><h4 id="3-4-2-集中式与分布式-3-dot-4-dot-2-集中式与分布式"><a href="#3-4-2-集中式与分布式-3-dot-4-dot-2-集中式与分布式" class="headerlink" title="3.4.2 集中式与分布式 {3-dot-4-dot-2-集中式与分布式}"></a>3.4.2 集中式与分布式 {3-dot-4-dot-2-集中式与分布式}</h4><p>集中式的控制器就是用一个实体来管理网络上的所有转发设备，（具有<strong>单点故障</strong>、<strong>拓展性很差</strong>的问题），一些 NOS 采用了高实时性系统来实现高吞吐量，大多基于多线程设计来利用多核并行执行的机制。值得注意的是，有个<strong>micro-NOS 采用基于<code>容器</code>的架构，实现了隔离应用程序并防止故障在整个 SDN 堆栈中传播的主要目标。</strong></p><p>分布式的控制器就比较有弹性，（大网络、小网络都能处理）。分布式的控制器可以是一个<strong>集中式的节点集群</strong>或<strong>物理上分布式的集合</strong>。前者可以实现高吞吐量，后者弹性和容错比较好，对于大型数据中心可以在数据中心内部使用集中式节点集群，而连接地理上分布的数据中心之间采用分布式的集合。</p><p>分布式控制器有些使用的是弱一致性语义，也就是说数据的更新不是同步的，在同一时刻不同节点读取同一个变量的值可能不同(new and old)，使用强一致性模型保证读到的是一样的值，更方便应用开发，但是会影响系统性能。</p><p>到目前（2005）为止，尽管某些控制器可以容忍崩溃故障，但它们不能容忍任意(arbitrary)故障，这意味着任何行为异常的节点都不会被行为良好的节点所替代。</p><p>但是<strong>SDN 的整体弹性是一个开放的挑战</strong>。</p><h4 id="3-4-3-解析-SDN-控制平面-3-dot-4-dot-3-解析-sdn-控制平面"><a href="#3-4-3-解析-SDN-控制平面-3-dot-4-dot-3-解析-sdn-控制平面" class="headerlink" title="3.4.3 解析 SDN 控制平面 {3-dot-4-dot-3-解析-sdn-控制平面}"></a>3.4.3 解析 SDN 控制平面 {3-dot-4-dot-3-解析-sdn-控制平面}</h4><p>多个 NOS 的比较：<br><img src="https://gitee.com/layer3/pic/raw/master/uPic/screen-shoot.png"><br>对上面几个平台的解剖，得到了如下清晰的 SDN 结构：<br><img src="https://gitee.com/layer3/pic/raw/master/uPic/20200402162606-9Tr84b.png"></p><p>在已有的控制平面中，一般都至少有如下三个 well-defined layers:</p><ul><li>the application, orchestration[^fn:4], services;</li><li>核心控制器函数；</li><li>南向通信的元素。</li></ul><p>控制平面较高的部分的连接是基于北向接口，例如 REST API 和 FML，Frenetic 和 NetCore，等语言；在控制平台的较低部分，是南向 API 和协议插件与转发元素接口。控制器平台的核心可以描述为其基础网络服务功能和各种接口的组合。</p><h4 id="3-4-4-核心控制器函数-3-dot-4-dot-4-核心控制器函数"><a href="#3-4-4-核心控制器函数-3-dot-4-dot-4-核心控制器函数" class="headerlink" title="3.4.4 核心控制器函数 {3-dot-4-dot-4-核心控制器函数}"></a>3.4.4 核心控制器函数 {3-dot-4-dot-4-核心控制器函数}</h4><p>举例有：拓扑、分析数据、通知、设备管理、最短路径转发和安全机制。</p><h4 id="3-4-5-南向-3-dot-4-dot-5-南向"><a href="#3-4-5-南向-3-dot-4-dot-5-南向" class="headerlink" title="3.4.5 南向 {3-dot-4-dot-5-南向}"></a>3.4.5 南向 {3-dot-4-dot-5-南向}</h4><p>类似于设备驱动，为上层提供通用接口，是的控制平面可以使用不同的南向 API（OpenFlow、OVSDB、ForCES）和协议插件来管理现有的或新的物理或虚拟设备，这对于<strong>向后兼容性</strong>和<strong>异构性</strong>都是至关重要的。一些控制器支持 OpenFlow 作为南向 API，但是 OpenDaylight 支持很多种，并且通过提供服务层抽象（Service Layer Abstract）更进一步，使得允许多个南向 API 和协议在控制平台中共存。</p><h4 id="3-4-6-东向和西向-3-dot-4-dot-6-东向和西向"><a href="#3-4-6-东向和西向-3-dot-4-dot-6-东向和西向" class="headerlink" title="3.4.6 东向和西向 {3-dot-4-dot-6-东向和西向}"></a>3.4.6 东向和西向 {3-dot-4-dot-6-东向和西向}</h4><p><img src="https://gitee.com/layer3/pic/raw/master/uPic/20200402204339-screen-shoot.png"><br>分布式控制器在当前每个控制器都实现其自己的东&#x2F;西向 API，这些接口的功能包括控制器之间的<strong>导入、导出数据</strong>，<strong>数据一致性模型的算法</strong>以及<strong>监视、通知功能</strong>（例如，检查控制器是否启动或通知一组转发设备的接管）。</p><p>实现东西向接口主要是定义通用要求以协调流设置并跨多个域交换可达性信息；Onix 数据导入&#x2F;导出功能,ForCES Intra-NE Coldstandby 机制以实现高可用性和分布式数据存储,高级数据分发机制，例如高级消息队列协议（AMQP），分布式并发和一致策略组合的技术，事务数据库和 DHT 或具有强大一致性和容错性的高级算法；</p><p>在多域设置中，东、西的 API 可能还需要 SDN 域控制器之间的更具体的通信协议此类协议的某些基本功能包括协调由应用程序发起的流设置，交换可达性信息以促进 SDN 之间的路由，可达性更新以保持网络状态一致等。同时还需要考虑异质性（heterogeneity）的问题，比如可能需要和非 SDN 兼容的交换机通信，控制器之间必须交换不同的信息，包括<strong>邻接关系</strong>和<strong>功能发现</strong>，<strong>拓扑信息</strong>（在管理域之间达成一致的协议范围内），<strong>计费信息</strong>，</p><p>有人给东西向做了区分：西向作为 SDN 到 SDN 协议和控制器 API，而东向接口将用于指代用于与旧版网络控制平面进行通信的标准协议</p><h4 id="3-4-7-北向-3-dot-4-dot-7-北向"><a href="#3-4-7-北向-3-dot-4-dot-7-北向" class="headerlink" title="3.4.7 北向 {3-dot-4-dot-7-北向}"></a>3.4.7 北向 {3-dot-4-dot-7-北向}</h4><p>当前的控制器提供了种类繁多的北向 API，例如 ad hoc API，RESTful API，多层编程接口，文件系统，以及其他更专业的 API，例如 NVP NBAPI 和 SDMN API 第 IV-E 节专门讨论北向 API 不断发展的层。第二种北向接口是源自 SDN 编程语言的接口，例如 Frenetic ，Nettle ，NetCore ，Procera ，Pyretic ，NetKAT 和其他查询基础语言。</p><h4 id="3-4-8-总结-3-dot-4-dot-8-总结"><a href="#3-4-8-总结-3-dot-4-dot-8-总结" class="headerlink" title="3.4.8 总结 {3-dot-4-dot-8-总结}"></a>3.4.8 总结 {3-dot-4-dot-8-总结}</h4><p>可以看出，大多数控制器都是集中式和多线程的。奇怪的是，北向 API 非常多样化。特别是，五个控制器（Onix，Floodlight，MuL，Meridian, SDN Unified Controller）对此接口的重视程度更高，以说明其重要性。一致性模型和容错功能仅出现在 Onix，HyperFlow，HP VAN SDN，ONOS 和 SMaRtLight 中。 最后，以 OpenFlow 标准作为南向 API 时，只有 Ryu 支持其三个主要版本（v1.0，v1.2 和 v1.3）。</p><p>控制平台是 SDN 成功的关键点之一 ，在这方面需要解决的主要问题之一是互操作性。因为这是南向 API（例如 OpenFlow）试图解决的第一个问题。 例如，虽然 WiFi 和 LTE 网络需要专用的控制平台，例如 MobileFlow 或 SoftRAN ，但数据中心网络具有可以通过 Onix 等平台满足的不同要求,或 OpenDaylight。 因此，在网络多样化、基础设施是 reality，不同控制器之间的协调与合作至关重要环境中，用于多控制器和多域部署的标准化 API 被视为实现此目标的重要步骤。</p><h3 id="3-5-Layer-V-Northbound-Interfaces-3-dot-5-layer-v-northbound-interfaces"><a href="#3-5-Layer-V-Northbound-Interfaces-3-dot-5-layer-v-northbound-interfaces" class="headerlink" title="3.5 Layer V: Northbound Interfaces {3-dot-5-layer-v-northbound-interfaces}"></a>3.5 Layer V: Northbound Interfaces {3-dot-5-layer-v-northbound-interfaces}</h3><p>目前南向接口基本上用的都是 OpenFlow，但是北向接口目前还挺丰富多样的，现有的控制器如 Floodlight、NOX、OpenDaylight 之类都定义了自己的北向接口，主要是因为使用场景还在不断进化，所以定义一个标准的北向接口还为时过早。与南向接口一样，都是软件实现的。北向接口的作用更像是操作系统中的 POSIX 标准，用来提高 App 的可移植性和互操作性。</p><p>最早的相关的工作比如 NOSIX，其尝试定一个可移植的 low-level（如流模型）应用接口，让南向 API 看起来像是设备驱动，但这个工作更像是对南向接口的高级抽象，而不能说是北向接口。后面的工作诸如 SDNet 将应用需求翻译成对底层服务的 request，yanc 基于 linux 和 VFS 这样的抽象，使得 SDN Apps 像使用文件一样来和底层设备通信。PANE 控制器允许网络管理员定义特定于模块的配额和对网络资源的访问控制策略。该控制器提供了一个 API，该 API 允许终端主机应用程序动态且自主地请求网络资源。</p><p>北向接口百花齐放，功能边界实际上还不是很清晰，ONF 结构工作包含了这样一种可能性，让北向 API 提供资源，最终从不同的业务和组织边界对客户应用程序进行网络资源的<strong>动态</strong>和<strong>粒度控制</strong>的可能性。</p><h3 id="3-6-Layer-VI-Language-Based-Virtualization-3-dot-6-layer-vi-language-based-virtualization"><a href="#3-6-Layer-VI-Language-Based-Virtualization-3-dot-6-layer-vi-language-based-virtualization" class="headerlink" title="3.6 Layer VI: Language-Based Virtualization {3-dot-6-layer-vi-language-based-virtualization}"></a>3.6 Layer VI: Language-Based Virtualization {3-dot-6-layer-vi-language-based-virtualization}</h3><p>虚拟化解决方案的两个基本特征是<strong>表达模块化</strong>的能力以及<strong>允许不同级别的抽象，同时仍保证所需属性</strong>的能力。举例来说，一个<strong>大交换机</strong>这样的抽象可以表示多个底层转发设备的联合。</p><p>Pyretic 通过引入网络对象提供了网络拓扑的高层抽象，这些对象包括网络拓扑和可以在对象上应用的一系列策略的集合。Splendid 采用的是静态分割来实现的抽象，网络由编译器根据应用程序层定义进行切片，编译器的输出是一个已经对网络的切片定义和配置命令进行了切片后的整体控制程序，Splendid 的切片有三个组件：拓扑（路由器、端口、链接）、切片级别的拓扑元件与网络元件的映射、packets 上的 predicates。将不同的应用程序与每个切片相关联，编译器采用切片（拓扑，映射和谓词）和相应程序的组合来生成整个网络的全局配置。</p><h3 id="3-7-Layer-VII-Programming-Languages-3-dot-7-layer-vii-programming-languages"><a href="#3-7-Layer-VII-Programming-Languages-3-dot-7-layer-vii-programming-languages" class="headerlink" title="3.7 Layer VII: Programming Languages {3-dot-7-layer-vii-programming-languages}"></a>3.7 Layer VII: Programming Languages {3-dot-7-layer-vii-programming-languages}</h3><p>对网络的可编程性要求正在从类似于 OpenFlow 的底层机器语言过渡到高层编程语言，底层语言本质上是模仿转发设备的行为，迫使开发人员在低级细节上花费过多时间，而不是在解决问题上花费太多时间。但是实现高层网络编程语言时总会遇到几个挑战，比如说如何是的单个应用程序的多任务之间不会互相影响，又或者是单个控制器上的多个应用程序规则之间冲突。</p><p>程序语言可以为特定的管理需求提供相应的抽象，还有一个很重要的特点是提供可移植性。另一个通过语言来抽象的更有趣的特性是，可以创建虚拟网络拓扑并为其编写程序，就像是面向对象的语言模式一样。不用为每个转发设备生成和安装规则，而是创建一个虚拟拓扑，这个虚拟拓扑可以表示整个网络也可以是网络的一个子集，举例来说，与上面的基于语言的虚拟化类似，可以将整个网络抽象为一个大交换机。当然，同样的也可以将一个大交换机抽象成多个虚拟交换机。</p><p>高级程序语言需要实现一下目标：</p><ul><li>避免传统网络配置方法中需要对低层和特定于设备进行配置，整个网络中各个部分互相依赖；</li><li>提供抽象概念，以通过易于理解和维护的网络策略来完成不同的管理任务；</li><li>解耦多个任务（例如，路由，访问控制，流量工程）；</li><li>实现更高级别的编程接口，以避免出现低级指令集（麻烦）；</li><li>解决转发规则问题，例如规则冲突或规则不完整，可能会阻止以自动方式触发切换事件；</li><li>解决分布式系统固有的不同 race condition 问题；</li><li>使用分布式决策生成器(decssion maker)在环境中增强解决冲突的技术；</li><li>在数据平面路径设置上提供本机容错功能；</li><li>减少处理新流的延迟；</li><li>简化有状态应用程序（例如，有状态防火墙）的创建。</li></ul><p>值得注意的是，文章提到了一个关键的网络基础结构：<a href="http://frenetic-lang.org/merlin/merlin-hotnets2013.pdf">Merlin</a>，其是一个用于控制不同网络组件（例如转发设备，中间盒和终端主机）的统一框架。Merlin 为每种类型的组件生成特定的代码。 以策略定义为输入，Merlin 的编译器确定转发路径，转换位置和带宽分配。 编译后的输出是要安装在设备中的针对不同组件的低级指令集。 Merlin 的策略语言还允许运营商将子网的控制权委派给租户，同时确保隔离。 这种委托控制是通过策略来表达的，每个租户所有者可以进一步细化这些策略，从而使他们可以根据自己的特定需求自定义策略。</p><h3 id="3-8-Layer-VIII-Network-Applications-3-dot-8-layer-viii-network-applications"><a href="#3-8-Layer-VIII-Network-Applications-3-dot-8-layer-viii-network-applications" class="headerlink" title="3.8 Layer VIII Network Applications {3-dot-8-layer-viii-network-applications}"></a>3.8 Layer VIII Network Applications {3-dot-8-layer-viii-network-applications}</h3><p>网络应用程序是网络的大脑，其主要用来指示转发设备的行为。文章举了一个例子，我觉得很好的揭示了 App 执行的过程：以路由来举例，这样的应用程序的逻辑是定义数据包从 A 点流向 B 点的路径。为了实现此目标，路由应用程序必须基于拓扑输入确定要使用的路径，然后指示控制器在从 A 到 B 的所选路径上的所有转发设备中安装相应的转发规则。</p><p>按照分类，一般有这样一些应用程序：</p><ul><li><code>流量工程(traffic engineering)</code><ul><li>主要就是 QoS，负载均衡，规则放置的优化（这个可能不属于这个分类），使用 MAC 作为全局标签来实现数据中心的路由（这个说是数据中心网络也未尝不可啊），流管理、错误回复，拓扑更新和 traffic characterization（可能是流量特征，流量刻画？）。大多数目标是以最小化功耗，最大化网络总利用率，提供优化的负载平衡以及其他通用流量优化技术为目的来设计流量。还有为视频和数据串流提供应用感知的网络</li><li>负载均衡的一个好处是可以让网络添加新设备变得很简单，自动将流量等任务分配给新设备。一个问题是如何让解决方法具有可扩展性，（一个方法是对 IP 前缀使用通配符来主动均衡，但是如果发现了阻塞就要是使用被动模式，这个是 tandem，可以研究看看）。现有的南向协议可以主动监测数据层的负载，可以用来优化网络的能源消耗，比如只能关闭连接和设备等；</li><li>数据中心网络的重要目标之一是避免或减轻网络瓶颈对所提供的计算服务的运行的影响。线性二等分带宽(linear bisection bandwidth)是一种可用于通过探索数据中心拓扑中的路径分集，而对网络造成压力(这里是一个作动词的 stress)的流量模式的技术。这样的技术又被用来提高聚集网络的利用而减轻 schedule 花费；</li><li>可以提供一个用来控制路由器配置的完全自治的系统，在用来提供虚拟聚集(aggregation)时很有用。可以用来减少路由表中的数据重复(how?)。</li><li>路径优化是另一个非常重要的研究对象，在 scale 很大的服务商中，动态扩展是很重要的，比如 VPN。并且最近的研究表是<code>规则放置(rules palcement)</code>的优化也能很好的提高网络效率。</li></ul></li><li><code>移动性和无线</code><ul><li>现有的分布式控制平台对无线网不适用于管理有限的频谱，分配无线电资源，实施切换机制，管理干扰以及在小区之间进行有效的负载平衡。</li><li>一个方法是提供了可编程的灵活的 stack layers，OpenRadio 将无线协议定义与硬件解耦，允许使用商品多核平台跨不同协议共享 MAC 层。OpenRadio 可被视为“无线网络的 OpenFlow”。</li><li>非常密集的异构无线网络也已成为 SDN 的目标。由于诸如无线电接入网络瓶颈，控制开销和高运营成本等约束，这些 DenseNet 具有局限性。 动态的两层 SDN 控制器层次结构可以适应这些约束中的某些约束。可以使用本地控制器来做出快速而细粒度的决策，而区域（或“全球”）控制器可以具有更广泛，更粗糙的粒度范围，即，执行速度较慢，但​​更具全局性的决策。以这种方式，设计具有挑战性的同时包含 LTE（宏_微微_毫微微）和 WiFi 小区的单一集成架构似乎是可行的。</li></ul></li><li><code>测量和监视</code><ul><li>主要分为两种：1. 为其他网络服务提供新功能的应用程序；2. 旨在改善基于 OpenFlow 的 SDN 功能的提议，例如减少由于收集统计信息而引起的控制平面过载。</li><li>第一种的一个做法是提高贷款性能的可视性，从而使系统能够对家庭网络中不断变化的状况做出反应。</li><li>第二种就是利用各种技术（stochastic and deterministic pakcet sampling, traffic matrix estimation …）减少控制平面在数据平面统计信息收集方面的负担。基本原语之间的解耦（例如匹配和计数）和更重的流量分析功能（例如检测异常情况攻击）</li></ul></li><li><code>安全性和可靠性</code><ul><li>同样的分为两种，一种是利用 SDN 来提高网络的安全性，另一种是提高 SDN 本身的安全性</li><li>SDN 允许在网络入口处执行强制策略，转发设备使及时收集来自网络的各种信息变得更加容易，这对于专门用于检测 DDoS 泛洪攻击的算法非常方便。非常适合与实现<code>主动安全Active Security</code>。检测攻击的方法可以分为如下三步：<ul><li>1）从不同来源收集数据（以识别攻击）；</li><li>2）收敛到安全设备的一致配置；</li><li>3）采取对策以阻止或最小化攻击的影响。</li></ul></li><li>早期的方法试图应用简单的技术，例如对应用程序进行分类和使用规则优先级划分，以确保安全应用程序生成的规则不会被较低优先级的应用程序覆盖。其他更进一步的提议试图通过提供一个用于在 SDN 中开发与安全相关的应用程序的框架。然而目前还是很难保证安全。</li></ul></li><li><code>数据中心网络</code><ul><li>实时网络迁移，改进的网络管理，避免重大故障， 从开发到生产网络的快速部署，故障排除，网络利用率的优化，中间盒即用的动态和弹性配置服务，并最小化流程建立延迟并降低控制器的运营成本。SDN 还可以为云应用程序提供网络原语，用于预测应用程序的网络传输的解决方案，对操作问题做出快速反应的机制，网络感知的 VM 放置，QoS 支持，实时网络监视和问题检测，安全策略执行服务和机制，并实现传输协议的程序化调整。</li><li>为了充分利用云中虚拟网络的潜力，一项基本功能是虚拟网络迁移。 与传统虚拟机迁移类似，当虚拟网络的虚拟机从一个地方移动到另一个地方时，可能需要迁移虚拟网络。为了实现此目标，有必要动态地重新配置所有受影响的网络设备（物理或虚拟）。 事实证明，这对于 SDN 平台（例如 NVP ）是可行的。</li><li>SDN 在数据中心的另一个潜在应用是检测网络运行中的异常行为，通过使用不同的行为模型并收集来自数据中心运营所涉及元素（基础架构，运营商，应用程序）的必要信息，可以通过被动捕获控制流量来为应用程序连续构建签名。 然后，签名历史可用于识别行为差异。 每次检测到差异时，操作员都可以采取反应或主动采取纠正措施。这可以帮助隔离异常组件并避免进一步破坏基础架构。</li></ul></li><li><code>SDN App Stores</code><ul><li>如题。</li></ul></li></ul><h3 id="3-9-Cross-Layer-Issues-3-dot-9-cross-layer-issues"><a href="#3-9-Cross-Layer-Issues-3-dot-9-cross-layer-issues" class="headerlink" title="3.9 Cross-Layer Issues {3-dot-9-cross-layer-issues}"></a>3.9 Cross-Layer Issues {3-dot-9-cross-layer-issues}</h3><h4 id="3-9-1-调试：-3-dot-9-dot-1-调试"><a href="#3-9-1-调试：-3-dot-9-dot-1-调试" class="headerlink" title="3.9.1 调试： {3-dot-9-dot-1-调试}"></a>3.9.1 调试： {3-dot-9-dot-1-调试}</h4><p>SDN 基于硬件的，与软件无关的控制功能以及使用开放标准进行控制通信和灵活性和可编程性可以潜在地使调试和故障排除更加容易。</p><p>ndb 提供类似于 gdb 的基本调试动作：breakpoint, watch, backtrace, single step.</p><p>OFRewind 的想法是记录和重播网络事件，特别是控制消息，允许操作员执行网络行为的细粒度跟踪，能够决定将记录网络的哪些子集，然后选择要重播的跟踪的特定部分，这些重放可提供有价值的信息，以查找网络行为异常的根本原因。NetRevert 与之相似，但是其更加关注在发生故障的情况下提供回滚恢复，这是分布式系统中用于消除节点中的瞬时错误的常用方法。</p><p>NetSight 可以重放 packet 的历史记录，packet 的历史记录与其用于遍历网络的路径相对应，并且在路径的每一跳中都对标头进行了修改，NetSight 其主要目标是允许使用数据包历史记录的应用程序被构建，以便发现网络中的问题。</p><h4 id="3-9-2-测试和验证-3-dot-9-dot-2-测试和验证"><a href="#3-9-2-测试和验证-3-dot-9-dot-2-测试和验证" class="headerlink" title="3.9.2 测试和验证 {3-dot-9-dot-2-测试和验证}"></a>3.9.2 测试和验证 {3-dot-9-dot-2-测试和验证}</h4><p>验证技术可用于检测和避免 SDN 中的问题，例如转发循环和黑洞。</p><p>NICE 生成一组不同的数据包流以测试尽可能多的事件，从而暴露出极端情况（例如竞争条件）。最终目标是测量控制应用程序和转发设备的处理能力和瓶颈。</p><p>FlowChecker 验证系统上的正确性属性违规， Alloy 识别意外行为，FlowGuard 在启用 OpenFlow 的网络中检测并解决违反安全策略的问题。VeriCon 通过分析各种网络事件序列，验证 SDN 应用程序在各种网络拓扑中的正确性。</p><p>Libra 用来解决大规模网络中的测试和验证问题，希望能越快越好地验证超大型网络中的转发表以查找路由错误，和可能会导致流量损失和安全漏洞。在大型网络中，由于路由状态的频繁更改，不可能假定网络快照在任何时候都是一致的。另一个重要问题与验证过程的完成速度有关，尤其是在时序要求非常严格的现代数据中心中。</p><p>Anteater 通过将交换机配置编码为布尔可满足性问题（SAT）实例来分析网络设备的数据平面状态，从而允许使用 SAT 求解器来分析网络状态。</p><h4 id="3-9-3-仿真-3-dot-9-dot-3-仿真"><a href="#3-9-3-仿真-3-dot-9-dot-3-仿真" class="headerlink" title="3.9.3 仿真 {3-dot-9-dot-3-仿真}"></a>3.9.3 仿真 {3-dot-9-dot-3-仿真}</h4><p>Just some different Simulate software.</p><p>[^fn:3]: 容器利用 Linux 特性实现隔离，主要有 2 个部分：<code>Namespace</code>，用来保证运行的进程的隔离性，其从宿主机中获得的资源（网络栈、进程列表和挂载点等）里获得仅自己可见的区域，对外界进程一无所知，放佛处于独占操作系统中；<code>CGroups</code>，用来限制环境中的资源使用情况，比如限制使用的 CPU 核心数、内存等。<br>[^fn:4]: 编排，自动化配置等。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问问题是否需要专业</title>
    <link href="/2020/03/19/2020-03-18/"/>
    <url>/2020/03/19/2020-03-18/</url>
    
    <content type="html"><![CDATA[<p><em>记录一件小事。</em></p><hr><p>世界真的很有趣。学习了一天，终于搭好了我的小博客，马不停蹄地看论文，希望能给博客充值一些干货。然而看一堆数学公式着实让人心累，好在立刻有人提醒我，除了分享技术，还可以写点别的。</p><p>事情的起因源于我在 v 站看到了这样一个帖子：“<a href="https://www.v2ex.com/t/652959">Mac pro 开虚拟机打游戏对电脑有伤害吗？</a>”。</p><p>并无冒犯的说，这样的标题让人忍俊不禁。楼主把帖子发在“新手求助”这样的 Node，也很有虚心求教的意思。但是无奈问题的表述实在让人无法进入想要好好回答的状态，也难免引起下面的回答者就 Mac pro 这个关键词进行“嘲讽”，说嘲讽非我所愿，其实最多也就是开个玩笑吧。</p><p>虽然任何与 Apple 产品相关的话题都会引来一片“嘲讽”，说实话，这样的交流气氛很不好，大家都在调侃楼主，有位同仁有些看不过去，于是说到：“众所周知，请尽量让自己的回复能够对别人有帮助。”但是我觉得根本原因还是在于楼主的提问方式，就我个人而言，我认为问题有二：</p><ul><li>一是开虚拟机打游戏对电脑的影响，应当是可以通过搜索引擎等手段查询到相关信息的,根据获得的信息应当会有一个基本的认知，在这个认知上提出更有针对性的问题应该会更好，比如 Mac 上的虚拟机与 PC 上的虚拟机实现机制不同，Mac 上使用虚拟机打游戏会更容易导致电脑元件老化吗？</li><li>二是“对电脑有伤害吗？”，这样的表述非常的不专业，不严谨，让人无法作答。</li></ul><p>于是我就回复了：“回答需要能提供帮助，但问问题也需要专业。不专业的问题引起的回答只能是互相冒犯。“有些故作深沉的味道，本意是想表达问问题前应当先做些准备的观点。第二天突然收到个通知“活久见”。</p><p>是先前的那位同仁对我的回复。无所谓嘛，不是一路人，也无意去和他辩论。</p><p>但让我想把这件事记录下来，是因为无意中让我看到了这篇帖子“<a href="https://www.v2ex.com/t/653673">在本 V 站提问题不够专业，是否会冒犯回答问题的人？</a>”</p><p>这真是有趣了。无论他是出于什么原因，也无论他这个问题提问得是否专业，我觉得他都冒犯到了我。</p><p>提问当然是需要准备的，无论什么地方，无论什么场合，都应尽量能做到专业。下面粘贴下<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh%5FCN.md">提问的艺术</a>中的“在提问之前”以共勉。</p><blockquote><p><strong>在提问之前</strong></p><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nothing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFlow</title>
    <link href="/2020/03/19/openflow/"/>
    <url>/2020/03/19/openflow/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍-1-dot-介绍"><a href="#1-介绍-1-dot-介绍" class="headerlink" title="1. 介绍 {1-dot-介绍}"></a>1. 介绍 {1-dot-介绍}</h2><p>这是 SDN 开山之作“OpenFlow: Enabling Innovation in Campus Networks”的阅读笔记，想要学习 SDN 到底是什么，能做什么，为什么，怎么做，还可以怎么做，研读开山之作显然是必不可少的。</p><p>文章的开篇主要阐述了作者实现 openflow 的主要目的，就是为了让研究人员能够在实际网络中测试他们提出的新方法，所以希望商用交换机和路由器可以提供一种通用的可编程的交换机，可以对流表执行一定的动作（action），并且为了不干扰生产生活中的网络，能够保证生产网络和研究网络的独立性。为此作者提出了这样的协议，文章有这样一句话：“hence<br>the commonly held belief that the network infrastructure has “ossified” ”，作者就是想要打破这种”ossified”，这样的胸怀也就不奇怪 OpenFlow 和 SDN 能够在学界引起如此庞大的影响了。</p><h2 id="2-OpenFlow-交换机-2-dot-openflow-交换机"><a href="#2-OpenFlow-交换机-2-dot-openflow-交换机" class="headerlink" title="2. OpenFlow 交换机 {2-dot-openflow-交换机}"></a>2. OpenFlow 交换机 {2-dot-openflow-交换机}</h2><h3 id="2-1-总览-2-dot-1-总览"><a href="#2-1-总览-2-dot-1-总览" class="headerlink" title="2.1 总览 {2-dot-1-总览}"></a>2.1 总览 {2-dot-1-总览}</h3><p>现在的交换机和路由器大多都提供了一个流表(<code>Flow Table</code>)，可以以线性速度实现防火墙、NAT、QoS 和数据统计信息等功能。 OpenFlow 为各种不同的交换机和路由器提供一种开放的协议来对流表进行编程。</p><h4 id="2-1-1-基本组成-2-dot-1-dot-1-基本组成"><a href="#2-1-1-基本组成-2-dot-1-dot-1-基本组成" class="headerlink" title="2.1.1 基本组成 {2-dot-1-dot-1-基本组成}"></a>2.1.1 基本组成 {2-dot-1-dot-1-基本组成}</h4><p>OpenFlow 交换机至少需要包括三个部分：</p><ul><li><code>流表(FlowTable)</code>，流表上的每个项(entry)关联的一个**动作(action)**，告诉交换机如何处理这个流[^fn:1]；</li><li><code>安全信道(Secure Channel)</code>，将交换机和远程控制进程(<em>controller</em>)链接，允许指令和包在交换机和控制器 controller 之间传送；</li><li><code>OpenFlow 协议</code>，为 Controller 和交换机之间通信提供一种标准方法。通过指定标准接口（OpenFlow 协议），可以从外部定义流表中的条目，而不用直接对交换机进行编程。</li></ul><p>![](figure src&#x3D;”&#x2F;ox-hugo&#x2F;2020-03-21_17-18-41_screen-shoot.png” class&#x3D;”foo” width&#x3D;”500”)</p><h4 id="2-1-2-Flow-Table-2-dot-1-dot-2-flow-table"><a href="#2-1-2-Flow-Table-2-dot-1-dot-2-flow-table" class="headerlink" title="2.1.2 Flow Table {2-dot-1-dot-2-flow-table}"></a>2.1.2 Flow Table {2-dot-1-dot-2-flow-table}</h4><p>OpenFlow 将交换机分为两种，一种是<strong>Dedicated OpenFlow switches</strong>，这种 OpenFlow 交换机不支持常规的 Layer 2 和 Layer 3 的处理，它在端口间按照远程 Controller[^fn:2] 定义的要求转发 packets。另一种则是在现有的商业路由器或交换机上添加 OpenFlow 的三要素的<strong>OpenFlow-enabled swithes</strong>，增加 OpenFlow 的支持。</p><p>每个 Flow-Table 中的 entry 由三个部分组成：</p><ul><li>定义 flow 的包头(header[^fn:3])，其中 header 的初步设计如下表所示；</li><li>定义怎么处理 packets 的动作(action)；</li><li>统计 Flow 中的 packets 数目和字节数的统计量。</li></ul><p>![](figure src&#x3D;”&#x2F;ox-hugo&#x2F;2020-03-21_18-12-39_screen-shoot.png” class&#x3D;”foo” width&#x3D;”500”)</p><p>针对每个 Flow Table 中的 Flow 关联的基础 Action 有：(<code>Type 0 要求</code>)</p><ul><li>转发 flow 中的 packets 到指定的端口（们），这提供了网络中的路由功能；</li><li>封装并转发 flow 中的 packets 到 controller，_通常情况下是把新的 flow 中的第一个 packet 过去，从而考虑是不是需要添加到 Flow Table 中去_；</li><li>drop packet，处于安全、防治 dos 攻击等考虑。</li><li>把 Flow 中的 packets 通过交换机传统的传统方式转发出去（_这是针对 OpenFlow 支持的商业交换机，可以分离[^fn:4]实验与生产数据_）</li></ul><h3 id="3-使用-3-dot-使用"><a href="#3-使用-3-dot-使用" class="headerlink" title="3. 使用 {3-dot-使用}"></a>3. 使用 {3-dot-使用}</h3><p>根据论文提供的案例，可以总结出如下大致步骤。首先定义一个流，将具有特定属性的数据包发送到控制器，然后在控制器中执行逻辑，然后将针对流的动作下放到个交换机，从而在一整个网络中完成对 Flow 的控制。</p><p>[^fn:1]: 流指的是网络中，具有相同属性的一类报文等，因此流的定义可能是广义的，具有相同的属性（可以指的是相同源 IP 地址，MAC 地址，端口等）的 pakcets 都可以被称之为是流。<br>[^fn:2]: 一个交换机可以被多个远程控制器控制。<br>[^fn:3]: Header 中的表项均可以通过通配符来进行匹配，从而聚集想要的流，实施策略。<br>[^fn:4]: 除了添加这个动作来分离实验与生产数据之外，还可以通过开议分离虚拟子网(VLANs)集合来分离这两种流量。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级计算机网络学习笔记</title>
    <link href="/2020/03/18/ad_computer_network/"/>
    <url>/2020/03/18/ad_computer_network/</url>
    
    <content type="html"><![CDATA[<p><em>This is for Adcanced Computer Networks learn note</em></p><h2 id="Part-I-Datacnter-Networks-part-i-datacnter-networks"><a href="#Part-I-Datacnter-Networks-part-i-datacnter-networks" class="headerlink" title="Part I Datacnter Networks {part-i-datacnter-networks}"></a>Part I Datacnter Networks {part-i-datacnter-networks}</h2><h3 id="1-FartTree-1-dot-farttree"><a href="#1-FartTree-1-dot-farttree" class="headerlink" title="1. FartTree {1-dot-farttree}"></a>1. FartTree {1-dot-farttree}</h3><h3 id="2-DCN-Portland-2-dot-dcn-portland"><a href="#2-DCN-Portland-2-dot-dcn-portland" class="headerlink" title="2. DCN-Portland {2-dot-dcn-portland}"></a>2. DCN-Portland {2-dot-dcn-portland}</h3><h4 id="2-1-Abstract-2-dot-1-abstract"><a href="#2-1-Abstract-2-dot-1-abstract" class="headerlink" title="2.1 Abstract {2-dot-1-abstract}"></a>2.1 Abstract {2-dot-1-abstract}</h4><h4 id="2-2-Design-2-dot-2-design"><a href="#2-2-Design-2-dot-2-design" class="headerlink" title="2.2 Design {2-dot-2-design}"></a>2.2 Design {2-dot-2-design}</h4><h4 id="2-3-Implementation-2-dot-3-implementation"><a href="#2-3-Implementation-2-dot-3-implementation" class="headerlink" title="2.3 Implementation {2-dot-3-implementation}"></a>2.3 Implementation {2-dot-3-implementation}</h4><h4 id="2-4-Tips-2-dot-4-tips"><a href="#2-4-Tips-2-dot-4-tips" class="headerlink" title="2.4 Tips {2-dot-4-tips}"></a>2.4 Tips {2-dot-4-tips}</h4><ul><li>与 FartTree 的连接方式不同，由于 FartTree 的连接方式是固定的，而 Portland 是没有固定的连接哪个交换机的哪个端口的要求的，同样的对编号也没有要求。</li><li>为什么要让 edge 投票选 id，因为冉 Aggre switch 来分配的会可能会冲突；</li><li>每个 switch 都会连接到 fabric manager，其作为 control plane 运行；</li><li>为什么需要 PMAC，因为 FatTree 中的 ip 地址是分配给虚拟机的，如果虚拟机迁移了，就要重新分配 ip，而是 PMAC 就不用进行手动来管理；</li></ul><h3 id="3-Helios：混合的电光交换机-Arch-for-Modular-Data-Centers-3-dot-helios-混合的电光交换机-arch-for-modular-data-centers"><a href="#3-Helios：混合的电光交换机-Arch-for-Modular-Data-Centers-3-dot-helios-混合的电光交换机-arch-for-modular-data-centers" class="headerlink" title="3. Helios：混合的电光交换机 Arch for Modular Data Centers {3-dot-helios-混合的电光交换机-arch-for-modular-data-centers}"></a>3. Helios：混合的电光交换机 Arch for Modular Data Centers {3-dot-helios-混合的电光交换机-arch-for-modular-data-centers}</h3><h4 id="3-1-介绍-3-dot-1-介绍"><a href="#3-1-介绍-3-dot-1-介绍" class="headerlink" title="3.1 介绍 {3-dot-1-介绍}"></a>3.1 介绍 {3-dot-1-介绍}</h4><p>什么是 Modular，指的就是数据中心的一个部分，里面是个完整的包含服务器、网络散热器等均已配置的很完善的一个模块数据中心。其实就是将数据中心模块化，将各个小的模块组织在一起就是一个大的数据中心。研究的重点就是怎么为 modular 之间实现好的通信。想法就是将带宽变成资源池，按需进行分配，节省成本。</p><h4 id="3-2-Ciuruit-Switch-3-dot-2-ciuruit-switch"><a href="#3-2-Ciuruit-Switch-3-dot-2-ciuruit-switch" class="headerlink" title="3.2 Ciuruit Switch {3-dot-2-ciuruit-switch}"></a>3.2 Ciuruit Switch {3-dot-2-ciuruit-switch}</h4><p>ppt 里的 circuit switch 和 optical switch 是一个意思。</p><p>作为第 0 层交换：物理层的交换，把 a 端口进来的光通过镜子反射到 b 端口出去。</p><p>波分复用：把多个光信号(比如红,黄,蓝色光)调制在一起传输，再通过解调器输出为多个光信号</p><h4 id="3-3-Simulation-3-dot-3-simulation"><a href="#3-3-Simulation-3-dot-3-simulation" class="headerlink" title="3.3 Simulation {3-dot-3-simulation}"></a>3.3 Simulation {3-dot-3-simulation}</h4><p>p：有 p 个端口连到交换机，c：有 c 个端口连接到光交换机；</p><p>M：所有的 pods 加一起共有 M 个端口连光交换机。</p><h4 id="3-4-Prototype-3-dot-4-prototype"><a href="#3-4-Prototype-3-dot-4-prototype" class="headerlink" title="3.4 Prototype: {3-dot-4-prototype}"></a>3.4 Prototype: {3-dot-4-prototype}</h4><p>把一些物理交换机利用 vlan 虚拟出来多个虚拟交换机用于 pods。一台物理交换机用作核心交换机，每个 pods 有一个端口连接到以太网交换机</p><p>每个光交换机连接到 pod 中的一个端口。</p><p>LAG:为指向某一个 pod 的物理<strong>光路</strong>端口指定一个为集合形成逻辑端口。如果 LAG 里的端口为 0 的话，就说明指向这个 pod 的数据应该走 packet switch。</p><p>通过现有的 traffic Matrix 估计出 Demand Matrix。</p><p>在 Demand Matrix 中，因为光交换的特点，每一行、每一列只能满足一个。</p><p><span class="underline">当 w&#x3D;4 时，即使有个 demand 是 7，但是仍然只能传 4，所以在点亮格子的计算时需要注意。</span></p><h4 id="3-5-总结-3-dot-5-总结"><a href="#3-5-总结-3-dot-5-总结" class="headerlink" title="3.5 总结 {3-dot-5-总结}"></a>3.5 总结 {3-dot-5-总结}</h4><p>Blocking Switch:打通一条路的代价是堵塞所有其他路，光交换机就是，而包交换机不是。</p><p>从 FatTree 开始，其只是一个拓扑结构，没有迁移、容错等问题，到了 Portland 其在资源增多时，需要大量的交换机。通过引入光交换机，Portland 中的大量交换机是为了应对最坏情况，这里通过观察的传输情况，对传输进行按需分配。</p><h3 id="Project-I-project-i"><a href="#Project-I-project-i" class="headerlink" title="Project I {project-i}"></a>Project I {project-i}</h3><p>beacon:ap 往外面发送的关于自身的 ssid 等信息的包；</p><h2 id="Part-II-Protocols-part-ii-protocols"><a href="#Part-II-Protocols-part-ii-protocols" class="headerlink" title="Part II Protocols {part-ii-protocols}"></a>Part II Protocols {part-ii-protocols}</h2><h3 id="1-MPTCP-1-dot-mptcp"><a href="#1-MPTCP-1-dot-mptcp" class="headerlink" title="1. MPTCP {1-dot-mptcp}"></a>1. MPTCP {1-dot-mptcp}</h3><h4 id="1-1-背景-1-dot-1-背景"><a href="#1-1-背景-1-dot-1-背景" class="headerlink" title="1.1 背景 {1-dot-1-背景}"></a>1.1 背景 {1-dot-1-背景}</h4><p>现在是一个路径上连接，希望能建立多条路径，能够和 TCP 公平竞争，应用程序兼容性。</p><p>在 TCP Option 字段定义 MP……指定使用 MPTCP。</p><p>huawei: Turbo Link</p><h4 id="1-2-Congestion-Control-1-dot-2-congestion-control"><a href="#1-2-Congestion-Control-1-dot-2-congestion-control" class="headerlink" title="1.2 Congestion Control {1-dot-2-congestion-control}"></a>1.2 Congestion Control {1-dot-2-congestion-control}</h4><p><code>有拥塞就退让，有空闲就争取</code>。</p><p>TCP 使用的 AMID，慢启动，快撤退；</p><p>对 MPTCP，算法的公示比较复杂，建议查看 ppt。收到 ACK 后，把<code>一些子流</code> 的窗口增大，但是如果丢包，则只把<code>该子流</code>的窗口减半。</p><p>对于 Coupled，不能把其他路径减到 0.至少要留一个 probe，就涨是全局的，但是跌只和自己相关。考虑 RTT 进行泛化之后得到了现在用的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Learn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>与主机上其他任务共享资源的分布式优化框架</title>
    <link href="/2020/03/18/flexible-distributed-optimization-fram/"/>
    <url>/2020/03/18/flexible-distributed-optimization-fram/</url>
    
    <content type="html"><![CDATA[<div class="ox-hugo-toc toc"><div></div><div class="heading">Table of Contents</div><ul><li><a href="#1-dot-%E4%BB%8B%E7%BB%8D">1. 介绍</a><ul><li><a href="#1-dot-1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%98%E5%8C%96">1.1 分布式优化</a></li><li><a href="#1-dot-2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AC%A1%E6%A2%AF%E5%BA%A6-subgrdient">1.2 什么是次梯度 <strong>subgrdient</strong></a></li><li><a href="#1-dot-3-%E7%AC%A6%E5%8F%B7%E8%A7%84%E5%AE%9A">1.3 符号规定：</a></li></ul></li><li><a href="#2-dot-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95">2. 模型与算法</a><ul><li><a href="#2-dot-1-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%9E%8B">2.1 问题模型</a></li><li><a href="#2-dot-2-%E7%AE%97%E6%B3%95">2.2 算法</a></li></ul></li><li><a href="#3-dot-%E6%94%B6%E6%95%9B%E7%BB%93%E6%9E%9C">3. 收敛结果</a><ul><li><a href="#"></a></li></ul></li></ul></div><!--endtoc--><h2 id="1-介绍-1-dot-介绍"><a href="#1-介绍-1-dot-介绍" class="headerlink" title="1. 介绍 {1-dot-介绍}"></a>1. 介绍 {1-dot-介绍}</h2><p>题目名为：A Flexible Distributed Optimization Framework for Service of Concurrent Tasks in<br>Processing Networks</p><h3 id="1-1-分布式优化-1-dot-1-分布式优化"><a href="#1-1-分布式优化-1-dot-1-分布式优化" class="headerlink" title="1.1 分布式优化 {1-dot-1-分布式优化}"></a>1.1 分布式优化 {1-dot-1-分布式优化}</h3><p>让一群没有服务器指挥的节点，在仅和邻居通讯（类似于 P2P）的情况下达到整体最优解。需要分布式优化的原因自然是因为 CS 架构的优化模型存在缺点，比如单点故障等原因，参考知乎<a href="https://www.zhihu.com/question/59260302">刘家耿的回答</a>，给出一个简单的形式化的表达式：<br>\[<br>  \min_{x_i,\cdots,x_n} \sum_{i&#x3D;1}^n f_i(x_i)<br>\]</p><p>上面的公示与常规的优化公示相对应，CS 架构的的优化公示中的 x 是全局统一的，存储在中心 server 上，而分布式优化的 x 则存储在每一个 client 上，这里再借用下上面的回答中的一个流程进一步的阐述分布式优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs english">for each node i, simultaneously<br>*repeat*<br>    do gradient updates with own data;<br>    regularly exchange some information with neighbors;<br>    combine information according to some policy;<br>*until* reach consensus and optimaticaly<br></code></pre></td></tr></table></figure><p>文章里描述的是，可以为机器学习和信号处理提供使用内部网络连接的处理通过间歇性通信来完成全局最优目标的方法。目前的很多分布式化算法假设所有的处理器都存储了相关数据，但实际上是很多全局最优任务是运行在共享资源的主机上的，所以需要提出一种能够灵活的和其他任务共享<strong>资源</strong>的分布式优化算法。</p><p>Here is a summary of classic and novel <strong>Distributed Optimization</strong></p><blockquote><p>One of the pioneering works on distributed optimization was Tsitsiklis et al.’s<br>work [22]. Since then, several types of methods have been proposed in this area,<br>such as distributed subgradient descent (DSD) [8], [14], distributed dual<br>averaging [4], [21], Alternating Direction Method of Multipliers (ADMM) [9],<br>[18], Nesterov’s method [15], [17] and second-order algorithm [10], [23], with<br>different performances and restrictions. Among these types, DSD is the most<br>important algorithm because it is easily implemented in a distributed way (ADMM<br>needs sequential variable updates and second order methods need costly<br>distributed Hessian calculation), and the basis of many further developed<br>algorithms. For example, by adding history gradient information to DSD, the<br>methods in [13] and [16] can achieve a linear convergence rate for the sum of<br>strongly convex and smooth functions with a constant stepsize. Nesterov’s method<br>can also be considered as a variant of the gradient method. So in this paper, we<br>will focus on gradient-based algorithms.</p></blockquote><p>文章提出一套灵活的分布式次梯度(subgradient)算法，允许处理器通过基于概率地在多个正在进行的任务之间切换，从而同时处理多个正在进行的任务。</p><h3 id="1-2-什么是次梯度-subgrdient-1-dot-2-什么是次梯度-subgrdient"><a href="#1-2-什么是次梯度-subgrdient-1-dot-2-什么是次梯度-subgrdient" class="headerlink" title="1.2 什么是次梯度 subgrdient {1-dot-2-什么是次梯度-subgrdient}"></a>1.2 什么是次梯度 <strong>subgrdient</strong> {1-dot-2-什么是次梯度-subgrdient}</h3><blockquote><p>当函数不可导时，无法通过常规的方法求梯度，也就无法使用梯度下降发来进行实现优化算法，因此针对存在不可导（不光滑）的函数提出其次梯度的概念，其标准定义为：</p><p>g 是函数 f 在 x 点的次梯度，当<br>\[<br>    f(y) \geq f(x) + g^T(y-x), \forall y<br>\]</p><p>上面的 g 是一个可能的次梯度，函数在某一点的次梯度是一个集合被记为&amp;part; f(x)，对于一个凸函数而言，其 &amp;part; f(x) 非空。所以可以使用类似于经典梯度下降的方法使用次梯度对不可导函数进行优化。</p></blockquote><h3 id="1-3-符号规定：-1-dot-3-符号规定"><a href="#1-3-符号规定：-1-dot-3-符号规定" class="headerlink" title="1.3 符号规定： {1-dot-3-符号规定}"></a>1.3 符号规定： {1-dot-3-符号规定}</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>\(n\)</td><td><strong>number</strong> of processors</td></tr><tr><td>\(x_i^k, y_i^k\)</td><td><strong>value</strong> of Processor i in iteration k</td></tr><tr><td>\(a_{ij}^k\)</td><td><strong>weight</strong> of processor i put on value sent from j</td></tr><tr><td>\(\partial f(x)\)</td><td><strong>set</strong> of <strong>subgradient</strong> of function at x</td></tr><tr><td>\(\nabla f(x)\)</td><td><strong>gradient</strong> of f at x</td></tr><tr><td>\(\Vert \cdot \Vert_p\)</td><td>\(l_p - norm\) for vectors</td></tr><tr><td>\(\pi \{x\}\)</td><td>\(\pi \{x\} &#x3D; \arg \min \limits_{y \in \chi} \Vert y-x \Vert_2^2\)</td></tr></tbody></table><h2 id="2-模型与算法-2-dot-模型与算法"><a href="#2-模型与算法-2-dot-模型与算法" class="headerlink" title="2. 模型与算法 {2-dot-模型与算法}"></a>2. 模型与算法 {2-dot-模型与算法}</h2><h3 id="2-1-问题模型-2-dot-1-问题模型"><a href="#2-1-问题模型-2-dot-1-问题模型" class="headerlink" title="2.1 问题模型 {2-dot-1-问题模型}"></a>2.1 问题模型 {2-dot-1-问题模型}</h3><p>考虑优化的问题与上面提到的分布式优化问题相似，这里再抄写一遍：</p><p>\[<br>    \min_\limits{m \in \chi} f(x) &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n f_i(x)<br>\]</p><p>其中 \(f_i(x)\) 对在 \(\chi\) 上的所以 i 都是凸的。网络是一个静态的无向图 \(G &#x3D; (V,<br>\xi)\) ，每个处理器 \(process_i\) 仅能访问自己本地函数 \(f_i\) 并计算起次梯度，同时<br>\(Process_i\) 可以与邻居通信自己的值，邻居被记为 \(N(i)\) 。</p><p>计算次梯度需要的花费记为 1，在 1 条链路上两个处理器的产生的通信开销记为 \(\tau\)</p><h3 id="2-2-算法-2-dot-2-算法"><a href="#2-2-算法-2-dot-2-算法" class="headerlink" title="2.2 算法 {2-dot-2-算法}"></a>2.2 算法 {2-dot-2-算法}</h3><p>对于一个有监督的分布式学习可以将每个处理器上的优化问题刻画为这个函数：<br>\(f_i(\theta) &#x3D; l (h(x_i; \theta), y_i)\) ，其中 h 是预测函数，l 是损失函数， \(x_i,<br>y_i\) 是处理器 i 本地存储的数据集中的数据， &amp;theta; 是希望全局优化的参数，下面给出三个假设：</p><ul><li>\(f_i(x)\) 的次梯度是有界的；字面意思；</li><li>\(f_i(x)\) 是 l 光滑的，(<em>Lipschitz smooth 利普希茨连续用来描述函数的平滑程度的，强调的是函数的梯度不会太突兀 L 是光滑程度，具体来说就是 x,y 两点的梯度差&lt;&#x3D; L|x-y|.</em>)</li><li>\(f_i(x)\) 是 &amp;mu; -strongly convex。</li></ul><p>分布式优化的目标是用做少的通信开销使得每个处理器上的 \(x_i^k\) 收敛到(1)式的最优解。这里的一个重要想法就是能否一次今更新所有处理器的一个子集上的值，该子集外的处理器做其他任务并保持子集的值不变，能否也可以达到全局优化的目标。文章介绍了一个基于概率的部分更新的次梯度算法(PUSD)的算法如下：</p><p>![](figure src&#x3D;”&#x2F;ox-hugo&#x2F;2020-03-18_11-42-07_screen-shoot.png” class&#x3D;”foo” width&#x3D;”500”)</p><p>其第 6-7 行是与其他主机交换信息的过程，第 8-14 行是根据概率选择是否计算次梯度以实现全局优化。</p><p>上面算法使用了概率划分的方法，实际上也有一些其他的硬划分模式，比如为不同的任务分配部分处理器数，但是对于有些时候数据因为隐私或者技术的原因不方便与其他处理器共享。上面的算法能够很好的估计出全局最优情况，但是在网络处理器上使用硬划分就很难做到（_这里留个问题，不是很理解为什么不能硬划分很难做到全局优化_）。</p><h2 id="3-收敛结果-3-dot-收敛结果"><a href="#3-收敛结果-3-dot-收敛结果" class="headerlink" title="3. 收敛结果 {3-dot-收敛结果}"></a>3. 收敛结果 {3-dot-收敛结果}</h2><h3 id=""><a href="#" class="headerlink" title="{}"></a>{}</h3>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Infocom2019</tag>
      
      <tag>Computer_Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
